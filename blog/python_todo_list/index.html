<!DOCTYPE HTML>

<html>
    <head>
        <script type="application/ld+json">
    {
        "@context" : "http://schema.org",
        "@type" : "BlogPosting",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "/"
        },
        "articleSection" : "blog",
        "name" : "Building A Todo List with Python and Flask",
        "headline" : "Building A Todo List with Python and Flask",
        "description" : "A guide on building a basic python application",
        "inLanguage" : "en",
        "author" : "",
        "creator" : "",
        "publisher": "",
        "accountablePerson" : "",
        "copyrightHolder" : "",
        "copyrightYear" : "0001",
        "datePublished": "0001-01-01 00:00:00 &#43;0000 UTC",
        "dateModified" : "0001-01-01 00:00:00 &#43;0000 UTC",
        "url" : "/blog/python_todo_list/",
        "wordCount" : "3106",
        "keywords" : [ "python","flask","practice","projects","Blog" ]
    }
    </script>
        
            
                <title>Building A Todo List with Python and Flask</title>
            
        

        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="generator" content="Hugo 0.38" />
        


        
            <meta name="author" content="Rebecca Skinner">
        
        
            <meta name="description" content="A guide on building a basic python application">
        

        <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Building A Todo List with Python and Flask"/>
<meta name="twitter:description" content="A guide on building a basic python application"/>
<meta name="twitter:site" content="@cercerilla"/>

        <meta property="og:title" content="Building A Todo List with Python and Flask" />
<meta property="og:description" content="A guide on building a basic python application" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/blog/python_todo_list/" />
















        <meta property="og:image" content="//images/logo.png">
        <meta property="og:image:type" content="image/png">
        <meta property="og:image:width" content="512">
        <meta property="og:image:height" content="512">
        
<meta itemprop="name" content="Building A Todo List with Python and Flask">
<meta itemprop="description" content="A guide on building a basic python application">



<meta itemprop="wordCount" content="3106">



<meta itemprop="keywords" content="python,flask,practice,projects," />

        

        
            
        

        
        
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
            <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway:400,800,900|Source+Sans+Pro:400,700">
            <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.css">
            <link rel="stylesheet" href="/css/main.css">
            <link rel="stylesheet" href="/css/add-on.css">
            <link rel="stylesheet" href="/css/academicons.min.css">
        

        
            
                
            
        


  
    
    <link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/github.min.css' rel='stylesheet' type='text/css' />
  


      
    </head>
    <body>

      
      <div id="wrapper">

    
    
<header id="header">
    
      <h1><a href="/">blog</a></h1>
    

    <nav class="links">
        <ul>
            
                <li>
                    <a href="/">
                            <i class="fa fa-home">&nbsp;</i>Home
                    </a>
                </li>
            
                <li>
                    <a href="/about/">
                            <i class="fa fa-id-card-o">&nbsp;</i>Resume
                    </a>
                </li>
            
                <li>
                    <a href="/blog/">
                            <i class="fa fa-newspaper-o">&nbsp;</i>Blog
                    </a>
                </li>
            
                <li>
                    <a href="/categories/">
                            <i class="fa fa-sitemap">&nbsp;</i>Categories
                    </a>
                </li>
            
                <li>
                    <a href="/contact/">
                            <i class="fa fa-envelope-o">&nbsp;</i>Contact
                    </a>
                </li>
            
        </ul>
    </nav>
    <nav class="main">
        <ul>
            
            <li id="share-nav" class="share-menu" style="display:none;">
                <a class="fa-share-alt" href="#share-menu">Share</a>
            </li>
            
            <li class="search">
                <a class="fa-search" href="#search">Search</a>
                <form id="search" method="get" action="//google.com/search">
                    <input type="text" name="q" placeholder="Search" />
                    <input type="hidden" name="as_sitesearch" value="/">
                </form>
            </li>
            <li class="menu">
                <a class="fa-bars" href="#menu">Menu</a>
            </li>
        </ul>
    </nav>
</header>


<section id="menu">

    
        <section>
            <form class="search" method="get" action="//google.com/search">
                <input type="text" name="q" placeholder="Search" />
                <input type="hidden" name="as_sitesearch" value="/">
            </form>
        </section>

    
        <section>
            <ul class="links">
                
                    <li>
                        <a href="/">
                            <h3>
                                <i class="fa fa-home">&nbsp;</i>Home
                            </h3>
                        </a>
                    </li>
                
                    <li>
                        <a href="/about/">
                            <h3>
                                <i class="fa fa-id-card-o">&nbsp;</i>Resume
                            </h3>
                        </a>
                    </li>
                
                    <li>
                        <a href="/blog/">
                            <h3>
                                <i class="fa fa-newspaper-o">&nbsp;</i>Blog
                            </h3>
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories/">
                            <h3>
                                <i class="fa fa-sitemap">&nbsp;</i>Categories
                            </h3>
                        </a>
                    </li>
                
                    <li>
                        <a href="/contact/">
                            <h3>
                                <i class="fa fa-envelope-o">&nbsp;</i>Contact
                            </h3>
                        </a>
                    </li>
                
            </ul>
        </section>

    
        <section class="recent-posts">
            <div class="mini-posts">
                <header>
                    <h3>Recent Posts</h3>
                </header>
                

                
                    
                

                
                        <article class="mini-post">
                            <header>
                                <h3><a href="/blog/python_and_nix/">Building Python Applications with Nix</a></h3>
                                
                                <time class="published" datetime=
                                    '2018-05-09'>
                                    May 9, 2018</time>
                            </header>
                            

                        </article>
                
                        <article class="mini-post">
                            <header>
                                <h3><a href="/blog/python_todo_list/">Building A Todo List with Python and Flask</a></h3>
                                
                                <time class="published" datetime=
                                    '0001-01-01'>
                                    January 1, 0001</time>
                            </header>
                            

                        </article>
                

                
            </div>
        </section>

    
        
</section>

    <section id="share-menu">
    <section id="social-share-nav">
        <ul class="links">
            <header>
                <h3>Share this post <i class="fa fa-smile-o"></i></h3>
            </header>
            
























<li>
  <a href="mailto:?subject=Check out this post by Rebecca%20Skinner&amp;body=%2fblog%2fpython_todo_list%2f" target="_blank" class="share-btn email">
    <i class="fa fa-envelope"></i>
    <p>Email</p>
  </a>
</li>


        </ul>
    </section>
</section>

    
    <div id="main">
        
        
        <article class="post">
  <header>
    <div class="title">
        
            <h1><a href="/blog/python_todo_list/">Building A Todo List with Python and Flask</a></h1>
            
        
        
            <p>A guide on building a basic python application</p>
        
    </div>
    <div class="meta">
        

        <time class="published"
            datetime='0001-01-01'>
            January 1, 0001</time>
        <span class="author">Rebecca Skinner</span>
        
            <p>15 minute read</p>
        
        
    </div>
</header>


  

  

  <div id="content">
    

<h1 id="introduction">Introduction</h1>

<p>NB: The full source code to this application is available <a href="https://github.com/rebeccaskinner/py-todo">on
github</a>.</p>

<p>The TODO List is a perrenial favorite of developers looking to learn a new
language, framework, or technique.  I recently joined a team that uses Python as
one of their languages, and decided to create my own implementation of a basic
todo list using python3 and Flask in order to hone my very rusty skills with
dynamically typed OO languages.  I decided to write up my thoughts here both to
help other developers who are interested in understanding how to get a start
with python, as well as offering a perspective to experienced python developers
on how those of us coming from outside the python ecosystem may approach solving
problems, and what hiccups we can encounter.</p>

<h1 id="defining-the-api">Defining the API</h1>

<p>The TODO list that we&rsquo;re building is going to focus on acting as a backend
service for some hypothetical rich frontend application.  We aren&rsquo;t concerned
with serving up HTML, CSS, or JavaScript.  Instead, we will concern ourselves
with implementing a simple JSON API, outlined below.</p>

<h2 id="the-api-endpoint">The API Endpoint</h2>

<p>The first thing I wanted to do as I was working through this project was to
ensure that my application&rsquo;s interfaces were well specified.  I wanted to limit
the scope of the project to something that could be accomplished in a few hours,
so rather than dive into understanding the python libraries for data interchange
formats like protobufs, and tools like swagger, I decided to create an ad-hoc
schema format for my API specification.  The schema describes both the routes
supported by the application, along with their HTTP methods and expected input
and output types, as well as describing the types themselves.  All data is
exchanged using JSON.</p>

<p>The schema that I&rsquo;m using is:</p>

<pre><code class="language-json">{
  &quot;description&quot;: &quot;human readable documentation string&quot;,
  &quot;endpoints&quot;: {
    &quot;routename&quot;: {
      &quot;http-method&quot;: {
        &quot;accepts&quot;: &quot;expected json type&quot;,
        &quot;returns&quot;: &quot;json schema of the returned payload&quot;,
        &quot;description&quot;: &quot;human readable documentation string&quot;
      }
    }
  },
  &quot;types&quot;: {
    &quot;type-name&quot;: {
      &quot;description&quot;: &quot;humand-readable documentation string&quot;,
      &quot;type&quot;: &quot;json type (object|array|number|string|bool) | typename&quot;,
      &quot;fields&quot;: {
        &quot;object-key-name&quot;: {
          &quot;description&quot;: &quot;object field description&quot;,
          &quot;type&quot;: &quot;json type (object|array|number|string|bool) | typename&quot;,
          &quot;required&quot;: &quot;bool&quot;
        }
      },
      &quot;values&quot;: [&quot;allowed-values&quot;]
      &quot;key-type&quot;: &quot;the type of keys in an object type&quot;
      &quot;value-type&quot;: &quot;the type of the values in an object type&quot;
    }
  }
}
</code></pre>

<p>Throughout the post I&rsquo;ll be incuding snippets of the JSON schema in the above
format to disambiguate any discussion around the contract for the TODO list API.</p>

<p>The API description is exposed at the <code>/api</code> route:</p>

<pre><code class="language-json">&quot;api&quot;: {
  &quot;get&quot;: {
    &quot;returns&quot;: &quot;object&quot;,
    &quot;description&quot;: &quot;returns this json document&quot;
  }
</code></pre>

<h2 id="tickets">Tickets</h2>

<p>A ticket in our TODO is a JSON object with two fields:</p>

<ul>
<li><code>status</code>: A textual description of the todo list item in human readable format</li>
<li><code>status</code>: A <code>status-string</code> type</li>
</ul>

<p>The status of a ticket describes it&rsquo;s current status.  The status type is a
string enumeration consisting of the following values:</p>

<ul>
<li><code>todo</code>: Indicates an item that has not been started</li>
<li><code>in-progress</code>: Indicates an item that has been started but not completed</li>
<li><code>abandon</code>: Indicates an item that was canceled before completing</li>
<li><code>done</code>: Indicates an item that has been completed</li>
</ul>

<p>The full description of the <code>ticket-json</code> and <code>status-string</code> types are shown
below:</p>

<pre><code class="language-json">{
  &quot;ticket-json&quot;: {
    &quot;description&quot;: &quot;json document describing a single ticket&quot;,
    &quot;type&quot;: &quot;object&quot;,
    &quot;fields&quot;: {
      &quot;status&quot;: {
        &quot;description&quot;: &quot;the status of a ticket&quot;,
        &quot;type&quot;: &quot;status-string&quot;,
        &quot;required&quot;: true
      },
      &quot;summary&quot;: {
        &quot;description&quot;: &quot;human readable description of the ticket&quot;,
        &quot;type&quot;: &quot;string&quot;,
        &quot;required&quot;: false
      }
    }
  },
  &quot;status-string&quot;: {
    &quot;description&quot;: &quot;string enumeration of ticket status&quot;,
    &quot;type&quot;: &quot;string&quot;,
    &quot;values&quot;: [
      &quot;todo&quot;,
      &quot;in-progress&quot;,
      &quot;abandoned&quot;,
      &quot;done&quot;
    ]
  }
}
</code></pre>

<h3 id="the-ticket-map">The Ticket Map</h3>

<p>Tickets in our application are referenced by ID numbers.  These ticket ID
numbers are simple JSON numbers, and we have created a type alias in our schema
for them to provide documentation:</p>

<pre><code class="language-json">&quot;ticket-id&quot;: {
  &quot;description&quot;: &quot;numeric id representing a ticket&quot;,
  &quot;type&quot;: &quot;number&quot;
}
</code></pre>

<p>The <code>ticket-map</code> type represents our association between ticket IDs and the
actual ticket values.  It&rsquo;s a javascript object keyed on string representations
of the <code>ticket-id</code> type and containing <code>ticket-json</code> values:</p>

<pre><code class="language-json">&quot;ticket-map&quot;: {
  &quot;description&quot;: &quot;map of ticket IDs to values&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;key-type&quot;: &quot;ticket-id&quot;,
  &quot;value-type&quot;: &quot;ticket-json&quot;
}
</code></pre>

<h2 id="todo-crud-operations">TODO CRUD Operations</h2>

<p>The TODO list supports basic CRUD operations.  We can view the todo list, either
in it&rsquo;s entirety or based on the state of the items.  Individual items in the
list can have their text updated, or can be moved from one state to another.
There is no limit on state transitions.</p>

<h3 id="global-operations">Global Operations</h3>

<pre><code class="language-json">&quot;items&quot;: {
  &quot;get&quot;: {
    &quot;returns&quot;: &quot;ticket-map&quot;,
    &quot;description&quot;: &quot;returns a list of all todo list items&quot;
  }
},
&quot;pending&quot;: {
  &quot;get&quot;: {
    &quot;returns&quot;: &quot;ticket-map&quot;,
    &quot;description&quot;: &quot;returns a list of all pending todo list items&quot;
  }
},
&quot;open&quot;: {
  &quot;get&quot;: {
    &quot;returns&quot;: &quot;ticket-map&quot;,
    &quot;description&quot;: &quot;returns a list of all open todo list items&quot;
  }
},
&quot;complete&quot;: {
  &quot;get&quot;: {
    &quot;returns&quot;: &quot;ticket-map&quot;,
    &quot;description&quot;: &quot;returns a list of all complete todo list items&quot;
  }
},
&quot;abandoned&quot;: {
  &quot;get&quot;: {
    &quot;returns&quot;: &quot;ticket-map&quot;,
    &quot;description&quot;: &quot;returns a list of all abandoned todo list items&quot;
  }
},
&quot;add&quot;: {
  &quot;post&quot;: {
    &quot;accepts&quot;: &quot;ticket-json&quot;,
    &quot;returns&quot;: &quot;ticket-id&quot;,
    &quot;description&quot;: &quot;adds a new todo list item&quot;
  }
}
</code></pre>

<h3 id="ticket-operations">Ticket Operations</h3>

<p>Individual tickets can be accessed by a route equal to the ticket&rsquo;s
<code>ticket-id</code>.  Tickets support <code>GET</code>, <code>DELETE</code>, and <code>PUT</code> methods to fetch,
remove, and update them respectively.</p>

<pre><code class="language-json">  &quot;&lt;ticket-id&gt;&quot;: {
    &quot;get&quot;: {
      &quot;returns&quot;: &quot;ticket-json&quot;,
      &quot;description&quot;: &quot;returns information about the given ticket&quot;
    },
    &quot;delete&quot;: {
      &quot;description&quot;: &quot;deletes a given ticket&quot;
    },
    &quot;put&quot;: {
      &quot;accepts&quot;: &quot;ticket-json&quot;,
      &quot;returns&quot;: &quot;ticket-json&quot;,
      &quot;description&quot;: &quot;updates ticket information&quot;
    }
  }
</code></pre>

<h1 id="defining-the-data-model">Defining the Data Model</h1>

<p>We define three object types that will represent the data we need in our
application.  The <code>TodoStatus</code> type is a specialization of the <code>Enum</code> class that
provides a mechanism to parse and display specific string representations of our
enum values.  The <code>TodoItem</code> type is a simple mutable object that tracks a given
item&rsquo;s description and completion state.  The <code>List</code> type is a mutable
collection of associations between todo item indexes and the items themselves.
Each of these types are described in more detail below.</p>

<h2 id="the-status-type">The Status Type</h2>

<p>Although python does not allow us to leverage a type system to detect errors at
compile time, we can still leverage the concept of sum types to allow us to
effective express the expected states of a todo item.  We accomplish this by
creating a subclass of the builtin enumeration type, <code>Enum</code>, and defining
numeric value mappings for each intended state.</p>

<pre><code class="language-python">class TodoStatus(Enum):
    TODO = 0
    INPROGRESS = 1
    ABANDON = 2
    DONE = 3
</code></pre>

<p>For convenience, we wish for our TodoStatus to provide an instance of the
stringification method <code>__str__</code>, allowing us to use basic print formatting
strings to generate appropriate human-readable names.  In this case, we will
explicitly exist the application if we find ourselves in an unexpected state in
order to avoid hiding any bugs caused by the unsoundness of our type system:</p>

<pre><code class="language-python">def __str__(self):
    if self == TodoStatus.TODO:
        return &quot;todo&quot;
    elif self == TodoStatus.INPROGRESS:
        return &quot;in-progress&quot;
    elif self == TodoStatus.ABANDON:
        return &quot;abandoned&quot;
    elif self == TodoStatus.DONE:
        return &quot;done&quot;
    else:
        print(&quot;enumeration invariant failed: value out of range&quot;)
        sys.exit()
</code></pre>

<p>Finally, as we will be wanting to parse user input in order to set the state of
a todo list item, we need to create a mapping from strings to our todo status.
We consider an invalid string to be part of the domain of our inputs, and return
<code>None</code> if we receive an invalid string.</p>

<p>Of particular note here is that we do not leverage a nullable container, as the
lack of compile-time enforcement of type constraints would render the benefits
of a nullable type nearly moot and would come at the cost of rather more verbose
interfaces.</p>

<pre><code class="language-python">def parse(str):
    if str == &quot;todo&quot;:
        return  TodoStatus.TODO
    elif str == &quot;in-progress&quot;:
        return  TodoStatus.INPROGRESS
    elif str == &quot;abandoned&quot;:
        return  TodoStatus.ABANDON
    elif str == &quot;done&quot;:
        return  TodoStatus.DONE
    else:
        return None
</code></pre>

<h3 id="testing-the-ticket-status">Testing The Ticket Status</h3>

<p>We will create unit tests for stringification and parsing of our status types.
Due to the very limited nature these are simple tests with full coverage.</p>

<pre><code class="language-python">class TestTodoStatus(unittest.TestCase):
    def test_to_string(self):
        self.assertEqual(&quot;todo&quot;, todo.TodoStatus.TODO.__str__())
        self.assertEqual(&quot;in-progress&quot;, todo.TodoStatus.INPROGRESS.__str__())
        self.assertEqual(&quot;abandoned&quot;, todo.TodoStatus.ABANDON.__str__())
        self.assertEqual(&quot;done&quot;, todo.TodoStatus.DONE.__str__())
    def test_parse_string(self):
        self.assertEqual(todo.TodoStatus.parse(&quot;todo&quot;), todo.TodoStatus.TODO)
        self.assertEqual(todo.TodoStatus.parse(&quot;in-progress&quot;), todo.TodoStatus.INPROGRESS)
        self.assertEqual(todo.TodoStatus.parse(&quot;abandoned&quot;), todo.TodoStatus.ABANDON)
        self.assertEqual(todo.TodoStatus.parse(&quot;done&quot;), todo.TodoStatus.DONE)
</code></pre>

<h2 id="the-todo-item-type">The Todo Item Type</h2>

<p>A todo list item is a mutable object that contains two fields: The <code>summary</code> is
the textual description of the contents of the todo list item.  The <code>status</code> is
the <code>TodoStatus</code> that describes the state of the ticket.</p>

<p>Todo items only have four basic operations:</p>

<ul>
<li>Get the summary</li>
<li>Set the summary</li>
<li>Get the status</li>
<li>Set the status</li>
</ul>

<p>We have three unit tests that cover these primary use cases:</p>

<pre><code class="language-python">def test_new_item_sets_summary(self):
    summary1 = &quot;test summary&quot;
    item = todo.TodoItem(summary1)
    self.assertEqual(summary1, item.description())
def test_set_summary(self):
    summary1 = &quot;test summary 1&quot;
    summary2 = &quot;test summary 2&quot;
    item = todo.TodoItem(summary1)
    item.set_summary(summary2)
    self.assertEqual(summary2, item.description())
def test_new_item_status_is_todo(self):
    item = todo.TodoItem(&quot;summary1&quot;)
    self.assertEqual(todo.TodoStatus.TODO, item.status())
</code></pre>

<p>Our implementations are straightforward:</p>

<pre><code class="language-python">class TodoItem:
    def __init__(self, summary):
        self._summary = summary
        self._status = TodoStatus.TODO
    def status(self):
        return self._status
    def set_status(self, status):
        self._status = status
    def description(self):
        return self._summary
    def set_summary(self, summary):
        self._summary = summary
</code></pre>

<p>We also provide several convenience methods that allow us to quickly set the
status to one of our pre-defined todo status types:</p>

<pre><code class="language-python">def todo(self):
    self._status = TodoStatus.TODO
def inprogress(self):
    self._status = TodoStatus.INPROGRESS
def abandon(self):
    self._status = TodoStatus.ABANDON
def complete(self):
    self._status = TodoStatus.DONE
</code></pre>

<p>One challenge that we&rsquo;ll face when serving our API is the need to convert our
todo items into the appropriate JSON representation as defined by our API.
Python does not provide a reasoanble serialization combinator to allow us to
easily encode our object directly into JSON, but we may abuse heterogenous
dictionary types in order to generate an object whose natural serialization
format is equivalent to our desired output format.</p>

<p>To accomplish this we define a <code>json_dict</code> function that will generate a
dictionary whose keys are the desired key names of the generated JSON object,
and whose values are likewise defined according to our specification:</p>

<pre><code class="language-python">def json_dict(self):
      return {&quot;summary&quot;: self._summary, &quot;status&quot;: self._status.__str__()}
</code></pre>

<h2 id="the-todo-list-type">The Todo List Type</h2>

<p>Our todo list is a simple container wrapping a dictionary keyed by ticket ID
numbers with values of type <code>TodoItem</code>. Our list type will support basic CRUD
operations as well as allowing us to filter and extract items based on their
completion state.</p>

<p>We start by writing tests that allow us to create an empty list, insert items
into it, and to verify that they exist:</p>

<pre><code class="language-python">def test_new_list(self):
    list = todo.List()
    self.assertEqual(0, list.total_count())
def test_add_item_returns_element_index(self):
    list = todo.List()
    summary = &quot;summary1&quot;
    id = list.add_item(summary)
    self.assertEqual(summary, list.lookup(id).description())
</code></pre>

<p>Creating our basic list is simple.  We define two internal private variables,
<code>_list</code>, which is initialized to an empty dictionary, and <code>_idx</code>, a stateful
method of tracking the last inserted index.</p>

<pre><code class="language-python">class List:
    def __init__(self):
        self._list = {}
        self._idx = 0
    def add_item(self, summary):
        idx = self._idx
        self._list[idx] = TodoItem(summary)
        self._idx = self._idx + 1
        return idx
    def lookup(self, idx):
        if idx not in self._list:
            return None
        return self._list[idx]
</code></pre>

<p>Next we provide several capabilities around looking at the total volume if
items, as well as removing items:</p>

<pre><code class="language-python">def test_remove_item_when_item_exists(self):
    list = todo.List()
    idx = list.add_item(&quot;summary&quot;)
    list.remove_item(idx)
    self.assertEqual(None, list.lookup(idx))
def test_remove_item_when_item_not_exists(self):
    list = todo.List()
    list.remove_item(999)
def test_list_size_increases_when_new_item_added(self):
    list = todo.List()
    list.add_item(&quot;summary&quot;)
    self.assertEqual(1, list.total_count())
def test_list_todo_item_shows_number_of_todo_items(self):
    list = todo.List()
    list.add_item(&quot;summary&quot;)
    self.assertEqual(1, list.total_count())
</code></pre>

<p>Implementing these functions requires little more than wrapping built-in
functions for dictionaries:</p>

<pre><code class="language-python">def total_count(self):
    return len(self._list)
def remove_item(self, idx):
    if idx in self._list:
        del self._list[idx]
</code></pre>

<p>We provide tests that prove that we can access collections of tickets given a
specific desired ticket state:</p>

<pre><code class="language-python">def test_list_open_items_returns_inprogress_items(self):
    list = todo.List()
    idx = list.add_item(&quot;summary&quot;)
    list.lookup(idx).inprogress()
    self.assertEqual({idx: list.lookup(idx)}, list.open_items())
    list.lookup(idx).complete()
    self.assertEqual({}, list.open_items())
def test_list_todo_items_returns_todo_items(self):
    list = todo.List()
    idx = list.add_item(&quot;summary&quot;)
    self.assertEqual({idx: list.lookup(idx)}, list.todo_items())
    list.lookup(idx).inprogress()
    self.assertEqual({}, list.todo_items())
</code></pre>

<p>Although we provide convenience methods to access all tickets for each of our
defined states, we abstract the actual lookup into a single method,
<code>items_by_state</code>:</p>

<pre><code class="language-python">def items_by_state(self, state):
    found = {}
    for key, item in self._list.items():
        if item.status() == state:
            found[key] = item
    return found
def open_items(self):
    return self.items_by_state(TodoStatus.INPROGRESS)
def todo_items(self):
    return self.items_by_state(TodoStatus.TODO)
def abandoned_items(self):
    return self.items_by_state(TodoStatus.ABANDON)
def complete_items(self):
    return self.items_by_state(TodoStatus.DONE)
</code></pre>

<p>The final step to finishing up or List class is, as with <code>TodoItem</code>, providing a
way to easily generate serialized json.  We will define a <code>json_dict</code> for our
<code>List</code> type as well, and simply call <code>json_dict</code> on each member of our
dictionary to generate the values in our JSON object:</p>

<pre><code class="language-python">def json_dict(self):
    items = {}
    for k, v in self._list.items():
        items[k] = v.json_dict()
    return items
</code></pre>

<h1 id="implementing-the-web-service">Implementing the Web Service</h1>

<p>Having defined the core components of our web service, we need to expose it to
users via HTTP.  We&rsquo;ll be using the <a href="http://flask.pocoo.org">Flask web
framework</a> to impelement our HTTP service.</p>

<p>We&rsquo;ll start by creating a flask application, this will be what handles our
application routing and manages the HTTP connections themselves:</p>

<pre><code class="language-python">app = Flask(__name__)
</code></pre>

<p>Next we need to create a <code>List</code> to use for user interactions:</p>

<pre><code class="language-python">list = List()
</code></pre>

<p>Flask uses the <code>.route</code> decorator to attach python functions to routes with the
framework.  The example below provides a very based route for <code>/</code> that directs
the user to review the documentation available at the <code>/api</code> route:</p>

<pre><code class="language-python">@app.route('/')
def home():
    return &quot;Not much to see here!  See '/api' for API documentation&quot;
</code></pre>

<p>The return value of functions that are attached to routes are polymorphic over
three value types:</p>

<ul>
<li>string: Where we return the HTTP response body as a simple string</li>
<li>(string, Dict string string): Returns a tuple with the http response body as a
string and a dictionary whose keys are HTTP response header names, and whose
values are the values for the associated header</li>
<li>(string, integer, Dict string string):   Returns a thruple of the http
response body as a string, the numeric HTTP status code, and a dictionary of
header names to header values</li>
</ul>

<h2 id="adapting-ticket-sets">Adapting Ticket Sets</h2>

<p>Many of our list functions return a dict mapping integers to tickets.  We need
to convert these returned types into an appropriate JSON-serializable type.  To
accomplish this we implement a function <code>convertDict</code> that will perform the
appropriate conversion:</p>

<pre><code class="language-python">def convertDict(item_map):
    result_map = {}
    for k, v in item_map.items():
        result_map[k] = v.json_dict()
    return result_map
</code></pre>

<h2 id="basic-query-routes">Basic Query Routes</h2>

<p>The majority of our HTTP endpoints are simply allowing the user to list tickets
with some basic filtration.  These each follow a similar basic pattern and are
shown collectively below:</p>

<pre><code class="language-python">@app.route('/api')
def help():
    with open(&quot;api.json&quot;) as f:
        contents = f.read()
    return (contents, {&quot;Content-Type&quot;: &quot;application/json&quot;})

@app.route(&quot;/items&quot;)
def items():
    return (json.dumps(list.json_dict()), {&quot;Content-Type&quot;: &quot;application/json&quot;})

@app.route(&quot;/open&quot;)
def open_items():
    return (json.dumps(convertDict(list.open_items())), {&quot;Content-Type&quot;: &quot;application/json&quot;})

@app.route(&quot;/complete&quot;)
def complete_items():
    return (json.dumps(convertDict(list.complete_items())), {&quot;Content-Type&quot;: &quot;application/json&quot;})

@app.route(&quot;/abandoned&quot;)
def abandoned_items():
    return (json.dumps(convertDict(list.abandoned_items())), {&quot;Content-Type&quot;: &quot;application/json&quot;})

@app.route(&quot;/pending&quot;)
def pending_items():
    return (json.dumps(convertDict(list.todo_items())), {&quot;Content-Type&quot;: &quot;application/json&quot;})
</code></pre>

<h2 id="creating-new-tickets">Creating New Tickets</h2>

<p>The <code>add</code> route is the first route we&rsquo;ve encountered that use an HTTP method
other than <code>GET</code>.  In this case, we expect the user to <code>POST</code> data to our
endpoint.  The POST body should contain JSON data that deserializes into a
dictionary containing a required summary and optional stating status.</p>

<pre><code class="language-python">@app.route(&quot;/add&quot;, methods=['POST'])
def add():
    data = request.get_json(force = True)
    f = lambda x: x
    if &quot;summary&quot; not in data:
        return (&quot;missing summary field&quot;, 400, {})
    if &quot;status&quot; in data:
        status = TodoStatus.parse(data[&quot;status&quot;])
        if status is None:
            return (&quot;invalid status&quot;, 400, {})
        f = lambda x: x.set_status(status)
    idx = list.add_item(data[&quot;summary&quot;])
    f(list.lookup(idx))
    return (&quot;{}&quot;.format(idx), {&quot;Content-Type&quot;: &quot;application/plaintext&quot;})
</code></pre>

<p>To implement this route, we use <code>request.get_json</code> to fetch the body of the HTTP
message as a dictionary generated by deserializing JSON (the <code>force = True</code>
parameter tells Flask to not require the user set the <code>Content-Type:
application/json</code> header- a conveninece for testing with curl.</p>

<p>After performing some basic validation to ensure the summary is set, and that if
a status has been set that it is a valid status, we create and configure the
todo list item, finally sending a plaintext response containing the stringified
numeric index of the newly added item.</p>

<h2 id="item-rud-operations">Item RUD Operations</h2>

<p>The individual ticket endpoints are the msot complicated of our routes.  We need
to capture the route into a variable and then support three separate requests
depending on the HTTP method used.</p>

<p>To implement this we start by creating a top level function for the route:</p>

<pre><code class="language-python">@app.route(&quot;/&lt;int:item_id&gt;&quot;, methods=['GET','PUT','DELETE'])
def item(item_id):
    if request.method == 'GET':
        return get_item(item_id)
    elif request.method == 'PUT':
        return update_item(item_id,request.get_json(force = True))
    elif request.method == 'DELETE':
        return remove_item(item_id)
</code></pre>

<p>The <code>&lt;int:item_id&gt;</code> syntax allows us to capture a variable from our route, and
provide Flask with a hint as to the type we expect to get.  The <code>request.method</code>
value allows us to look at the HTTP request type.  We use this information to
call out to one of three specialized functions that will handle the work for
each of the actions dictated by the HTTP methods:</p>

<h3 id="getting-an-item">Getting an Item</h3>

<p>Getting an item is straighforward.  We look in our list for the item ID.  If
it&rsquo;s found we convert it to JSON and return the value, otherwise we return an
HTTP status code 404.</p>

<pre><code class="language-python">def get_item(item_id):
    item = list.lookup(item_id)
    if item is None:
        return (&quot;no such item&quot;, 404, {})
    return (json.dumps(item.json_dict()), {&quot;Content-Type&quot;: &quot;application/json&quot;})
</code></pre>

<h3 id="removing-an-item">Removing an Item</h3>

<p>Removing an item will never fail, allowing the user to remove items without
first querying to see if they have already been removed.  Our remove function
simply calls <code>list.remove_item</code> and then returns an HTTP status code 200.</p>

<pre><code class="language-python">def remove_item(item_id):
    list.remove_item(item_id)
    return (&quot;&quot;,200,{})
</code></pre>

<h3 id="updating-an-item">Updating an Item</h3>

<p>Our update process works very much like our <code>add</code> endpoint, with the addition of
a verification step to ensure that the item already exists.  We also treat the
summary field as optional rather than required as it is when we are creating a
new item.</p>

<pre><code class="language-python">def update_item(item_id, item_map):
    item = list.lookup(item_id)
    if item is None:
        return (&quot;no such item&quot;, 404, {})
    if &quot;status&quot; in item_map:
        parsed = TodoStatus.parse(item_map[&quot;status&quot;])
        if parsed is None:
            return (&quot;invalid status&quot;, 400, {})
        item.set_status(parsed)
    if &quot;summary&quot; in item_map:
        item.set_summary(item_map[&quot;summary&quot;])
    return (json.dumps(item.json_dict()), {&quot;Content-Type&quot;: &quot;application/json&quot;})
</code></pre>

<h1 id="conclusion">Conclusion</h1>

<p>Without much experience developing python applications, this simple application
ended up taking me approximately 5 hours to build from start to finish.  I found
approximately 80% of that time amounted to looking for errors that would have
been detected by the type system of even a rudimentary typed language.</p>

<p>Compared to Go, I found the APIs for defining endpoints a bit simpler due to the
lack of support for pluggable middleware systems, but the lack of obvious
support of mocking the HTTP server makes code testability a problem.  Comapred
to haskell with Servant I found the process of API definition tedious, the JSON
serialization absurdly contorted, and the lack of type safety more than doubled
the amount of time required to complete the application.</p>

<p>While I have a much greater apprecation for the capabilities of Python for
developing web applications, I am unlikely to pick it up as a first, or even
fourth or fifth option for any restful services I develop in the future.</p>

  </div>

  <footer>
    <ul class="stats">
  <li class="categories">
    <ul>
        
            
            
                <i class="fa fa-folder"></i>
                
                
                <li><a class="article-category-link" href="/categories/python">python</a></li>
                
                
                <li><a class="article-category-link" href="/categories/flask">flask</a></li>
                
            
        
    </ul>
  </li>
  <li class="tags">
    <ul>
        
            
            
                <i class="fa fa-tags"></i>
                
                
                <li><a class="article-category-link" href="/tags/python">python</a></li>
                
                
                <li><a class="article-category-link" href="/tags/flask">flask</a></li>
                
                
                <li><a class="article-category-link" href="/tags/practice">practice</a></li>
                
                
                <li><a class="article-category-link" href="/tags/projects">projects</a></li>
                
            
        
    </ul>
  </li>
</ul>

  </footer>

</article>

    <article class="post">
        <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "shortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </article>


<ul class="actions pagination">
    

    
        <li><a href="/blog/python_and_nix/"
                class="button big next">Building Python Applications with Nix</a></li>
    
</ul>


    </div>
    
<section id="sidebar">

  
  <section id="intro">
    
    
      
        <a href='/'><img src="/img/main/logo.png" width="" alt="Hugo Future Imperfect" /></a>
      
    
    
      <header>
        <h2>Rebecca Skinner</h2>
        <p>Thougs on functional languages, technology, teaching, and industry.</p>
      </header>
    
    
  </section>

  
  <section class="recent-posts">
    <div class="mini-posts">
      <header>
        <h3>Recent Posts</h3>
      </header>
      <div class="posts-container">
        

        
          
        

        
          <article class="mini-post">
            <header>
              <h3>
                <a href="/blog/python_and_nix/">Building Python Applications with Nix</a>
              </h3>
              
              <time class="published" datetime='2018-05-09'>
                May 9, 2018
              </time>
            </header>
            

          </article>
        
          <article class="mini-post">
            <header>
              <h3>
                <a href="/blog/python_todo_list/">Building A Todo List with Python and Flask</a>
              </h3>
              
              <time class="published" datetime='0001-01-01'>
                January 1, 0001
              </time>
            </header>
            

          </article>
        
      </div>

      
    </div>
  </section>

  
  
  
  
  
    <section id="categories">
      <header>
        <h3>
          <a href="/categories/">Categories</a>
        </h3>
      </header>
        
          
        

        
        <p>
          <article>
            <header>
              
                <a href="/categories/python/">python</a>
                <span style="float:right;">2</span>
              
            </header>
          </article>
        </p>
        
        <p>
          <article>
            <header>
              
                <a href="/categories/flask/">flask</a>
                <span style="float:right;">1</span>
              
            </header>
          </article>
        </p>
        
        <p>
          <article>
            <header>
              
                <a href="/categories/nix/">nix</a>
                <span style="float:right;">1</span>
              
            </header>
          </article>
        </p>
        
    </section>
  
  

  
  
    <section id="mini-bio">
      <h3>About</h3>
      <p>Rebecca Skinner is a software developer, speaker, and author based in St. Louis, Missouri.  Her interests include functional programming languages, distributed systems, signal processing, computer vision, and data science.</p>
      <a href="/about/" class="button">Learn More</a>
    </section>
  

  
  <section id="footer">
    
    <p class="copyright">
      
        &copy; 2018
        
          Rebecca Skinner
        
      .
      Powered by <a href="//gohugo.io" target="_blank">Hugo</a>
    </p>
  </section>
</section>

    </div>
    <a id="back-to-top" href="#" class="fa fa-arrow-up fa-border fa-2x"></a>
    

    
      
    

    
      
      
      
        <script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>
        
        
        
        <script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
        <script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
        <script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/css.min.js"></script>
        <script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>
      
    
    
    
      <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/skel/3.0.1/skel.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.25/jquery.fancybox.min.js"></script>
      <script src="/js/util.js"></script>
      <script src="/js/main.js"></script>
      <script src="/js/backToTop.js"></script>
    

    
      
        
      
    

    
    <script>hljs.initHighlightingOnLoad();</script>
      <script src="//yihui.name/js/math-code.js"></script>
<script async
src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


  </body>
</html>

