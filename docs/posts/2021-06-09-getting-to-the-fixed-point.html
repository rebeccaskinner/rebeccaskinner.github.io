<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Rebecca Skinner - The Fixed Point</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="icon" type="impage/png" href="../favicon.png">

        <meta property="og:type" content="article" />
        <meta property="og:site_name" content="RebeccaSkinner.net" />
        <meta property="og:image" content="https://rebeccaskinner.net/images/site-image-banner.png" />
        <meta property="og:title" content="The Fixed Point" />

        
        <meta property="og:article:published_time" content="June  9, 2021" />
        

        

        
        <meta property="og:description" content="Learn about laziness, recursion, and fixed points in this beginner level haskell article." />
        


    </head>
    <body>
        <header>
          <div class="logo">
            <a href="../">Rebecca Skinner</a>
          </div>
            <nav>
              <a href="../resume.html">Resume</a>
              <a href="https://github.com/rebeccaskinner/">Github</a>
              <a href="https://twitter.com/cercerilla">Twitter</a>
              <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>The Fixed Point</h1>
            <article>
  <section class="header">
    Posted on June  9, 2021
    
    by Rebecca Skinner
    
  </section>
  <section>
    <h2 id="getting-to-the-fixed-point">Getting To The (Fixed) Point</h2>
<p>Haskell offers ample opportunities for ah ha! moments, where figuring out just how some function or feature works can unlock a whole new way of thinking about how you write programs. One great example of an ah-ha moment comes from when you can first start to understand fixed points, why you might want to use them, and how exactly they work in haskell. In this post, you’ll work through the fixed point function in haskell, building several examples along the way. At the end of the post you’ll come away with a deeper understanding of recursion and how haskell’s lazy evaluation changes the way you can think about writing programs.</p>
<p>If you already have some experience with haskell, you may want to <a href="#part2">skip the first section and jump directly into learning about fix</a></p>
<h2 id="a-quick-look-at-recursion-in-haskell">A Quick Look at Recursion in Haskell</h2>
<p>A recursive function is a function that refers back to itself. There are different ways that you can accomplish recursion, and throughout this article we’ll look at several of them. We’ll start by defining a couple of new terms to help us differentiate some particular aspects of recursion that will matter as we’re exploring fixed points: <em>manual recursion</em>, <em>automatic recursion</em>, and <em>recursive bindings</em>. Throughout this section of the article we’ll spend some time with each of these types of recursion, building up some examples and working our way towards a better understanding of how they let us think about the general nature of recursion and how it relates to fixed points.</p>
<h3 id="manual-recursion">Manual Recursion</h3>
<p>We’ll start our investigation of recursion by thinking about <em>manual recursion</em>. When you are first learning haskell, manual recursion is probably the thing you think about when you think about the word recursion. We call it manual recursion because it occurs when you, the programmer, directly make a recursive call back to the function you are currently writing.</p>
<p>Let’s look at a classic example of recursion written in a directly recursive style. We’ll start by writing a <code>factorial</code> function. If you’re not familiar with <code>factorial</code>, it’s a function that when given 0, returns 1. When given a number greater than 0, <code>n</code>, it gives you the result of multiplying all of the numbers from <code>1</code> to <code>n</code>. For example:</p>
<pre><code>factorial 5 = 1 * 2 * 3 * 4 * 5 = 120</code></pre>
<p>To make things a bit easier on ourselves in the next step, let’s think about the factorial function as <em>counting down</em> from our input number, instead of <em>counting up</em> toward it, so we can say:</p>
<pre><code>factorial 5 = 5 * 4 * 3 * 2 * 1 = 120</code></pre>
<p>The first thing we need to do is to think about how we can take our factorial function and break it down into increasingly smaller pieces that have the same <em>shape</em> as our overall function. Whenever we’re writing a recrusive function, it helps to start by looking at how we can reframe the problem in terms of something getting smaller.</p>
<p>One way to see how we can break <code>factorial</code> down into smaller pieces is to notice that:</p>
<pre><code>factorial 5 = 5 * 4 * 3 * 2 * 1
factorial 4 =     4 * 3 * 2 * 1</code></pre>
<p>So we can rewrite <code>factorial 5</code> to say:</p>
<pre><code>factorial 5 = 5 * (4 * 3 * 2 * 1)
            = 5 * (factorial 4)</code></pre>
<p>If we go one more step, we can see that:</p>
<pre><code>factorial 4 = 4 * (3 * 2 * 1)
factorial 3 =     (2 * 2 * 1)

factorial 4 = 3 * (factorial 3)</code></pre>
<p>From these examples you can start to see the shape of the recursive function that we’ll be writing, and how the sub-problem that we are solving at each step gets a little bit smaller.</p>
<p>The next thing we want to think about before we write a recursive function is when we should stop. This is called the <em>base case</em>. For our factorial function, the base case is the smallest number that we can calculate a factorial for, which is 0 and that’s given to us by the definition of factorial.</p>
<p>With that information in hand, we can write our factorial function using direct recursion.:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>factorial n <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> n <span class="kw">of</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dv">1</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">-&gt;</span> n <span class="op">*</span> (factorial (n <span class="op">-</span> <span class="dv">1</span>))</span></code></pre></div>
<h3 id="automatic-recursion">Automatic Recursion</h3>
<p>Unlike manual recursion, where we can see the recursive structure of our function by looking for the place in our code where a function calls itself, a function that is using <em>automatic recursion</em> does so indirectly, using a function that manages the recursion for us automatically.</p>
<p>One example of automatic recursion that you’re likely familiar with are the fold functions: <code>foldl</code> and <code>foldr</code>. These two functions, and others like them, allow you to work on data that can naturally be traversed recursively while only having to implement the code to deal with the current element and any state that you want to carry over across calls.</p>
<p>We can use a function like <code>foldr</code> to write a <code>factorial</code> by letting it do the recursion for us:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>factorial n <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    handleStep currentNum currentFact <span class="ot">=</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      currentNum <span class="op">*</span> currentFact</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="fu">foldr</span> handleStep <span class="dv">1</span> [<span class="dv">1</span><span class="op">..</span>n]</span></code></pre></div>
<p>Even if you’ve used <code>foldr</code> before, it will be helpful as we’re framing the problem to build a version of it ourselves, so that we can think through how these sorts of recursive functions work.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f accum items <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> items <span class="kw">of</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      accum</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    (next<span class="op">:</span>rest) <span class="ot">-&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      f next (<span class="fu">foldr</span> f accum rest)</span></code></pre></div>
<p>Looking at this function, you can see how the shape of the function, with the <code>case</code> statement, the base case with an empty list, and the recursive call that each time moves one element forward in the list. Our implementation of <code>foldr</code> is more generic to be sure- we’ve replaced the knowledge that <code>factorial 0</code> is <code>1</code> with a more general statement that the value of our fold at our base case is the initial accumulator value that was provided, and now instead of doing multiplication directly in our recursive call we hand off the details to a function that is passed in, but if you squint a bit you can see how similar the two functions really are.</p>
<p>Using functions like folds that deal with the shape of the data and handle the recursion for us has a number of benefits. First, it removes some unnecessary duplication of code. Traversing data structures and doing something on all of the elements is quite common in functional programming, and if we were to implement it from scratch each time it would take us much longer to write programs, and there are many more opportunities for errors. Second, it makes our code a bit more readable by letting us center the “business logic” of our function. In most cases, the fact that our data is represented as a list, a binary tree, etc. is incidental to the problem at hand. By separating out the logic for dealing with individual elements from the logic for traversing data structures, we center the relevant bits of our code. Finally, and perhaps most importantly, functions like folds give us a common language for talking abou the structure of our programs. For someone who has been programming for some time, saying that something is “simply a fold over some data” can convey a good deal of information about the general idea of how a program is implemented without the need to bog them down in too many extraneous details.</p>
<h3 id="recursive-let-bindings">Recursive Let Bindings</h3>
<p>The final type of recursion we’ll look at in this first section is not so much a specific technique to do recursion as it is a feature of haskell that allows you to use manual recursion more easily: <em>recursive let bindings</em>.</p>
<p>Haskell’s recursive let bindings mean that you can use recursion inside of a <code>let</code> expression in your function. A simple example of this would be, continuing with our factorial example, a function that computers the <em>double factorial</em>, that is to say, the factorial of the factorial of an input number:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Note: This function grows very quickly.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   doubleFactorial 5 is a 199-digit number</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   doubleFactorial 8 is a 168187-digit number</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">doubleFactorial ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>doubleFactorial n <span class="ot">=</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    factorial a <span class="ot">=</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> a <span class="kw">of</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dv">1</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        a <span class="ot">-&gt;</span> a <span class="op">*</span> factorial (a <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> factorial (factorial n)</span></code></pre></div>
<h2 id="fixing-functions"><a id="part2">Fixing Functions</a></h2>
<p>The <code>fix</code> function, defined in <code>Data.Function</code> in <code>base</code>gives us another way to approach recursion in haskell. Let’s start by taking a look at <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Function.html#v:fix">the documentation for fix</a>:</p>
<h3 id="fix-by-the-docs">Fix By The Docs</h3>
<p>For ease of readability, the documentation for <code>fix</code> is reproduced below:</p>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Function.html#v:fix">fix</a> <code>f</code>is the least fixed point of the function <code>f</code>, i.e. the least defined <code>x</code> such that <code>f x = x</code>.</p>
<p>For example, we can write the factorial function using direct recursion as</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>λ <span class="kw">let</span> fac n <span class="ot">=</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> fac (n<span class="op">-</span><span class="dv">1</span>) <span class="kw">in</span> fac <span class="dv">5</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dv">120</span></span></code></pre></div>
<p>This uses the fact that Haskell’s <code>let</code> introduces recursive bindings. We can rewrite this definition using ‘fix’,</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>λ fix (\rec n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)) <span class="dv">5</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dv">123</span></span></code></pre></div>
<p>Instead of making a recursive call, we introduce a dummy parameter <code>rec</code>; when used within <code>fix</code>, this parameter then refers to <code>fix</code>’s argument, hence the recursion is reintroduced. <code>fix :: (a -&gt; a) -&gt; a</code></p>
<h3 id="untangling-the-type-of-fix">Untangling the Type of fix</h3>
<p>Whenever we want to understand something new in haskell, a good first instinct is to start by looking at the types, as this tells us quite a bit about what a function can, and often more importantly <em>can’t</em> do.</p>
<p>The type of <code>fix :: (a -&gt; a) -&gt; a</code> tells us that it’s going to take a function, and return a value. For the sake of discussion, let’s give the function that we pass into <code>fix</code> the name<code>g</code>. So, <code>g :: a -&gt; a</code> and <code>fix g :: a</code>.</p>
<p>At first look, this might not look all that difficult at all. <code>fix</code> just needs to call <code>g</code> with a value to get a value back out that it can return. We can imagine any number of similar functions that would work for some specific type, an <code>Int</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applyZero ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>applyZero g <span class="ot">=</span> g <span class="dv">0</span></span></code></pre></div>
<p>Similarly, we can think of any number of candidates for <code>g</code> that we could pass in and get a good result back out:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>λ applyZero (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>λ applyZero (<span class="op">*</span><span class="dv">4</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span></code></pre></div>
<p>Unfortunately, this relies on the fact that <code>applyZero</code> can pick some number to pass in. It can do that because we know that it’s working with <code>Int</code> values, so we can pick an <code>Int</code> value to pass into it. <code>fix</code> doesn’t have things so easy- since <code>a</code> could be <em>anything</em> there’s no value we can pick to pass into <code>g</code> to get back a value.</p>
<p>We can see this play out if we try to pass some function, like <code>(+1)</code> into <code>fix</code>: It will never give us back a value, because <em>it can’t</em>. You can try it yourself in ghci. When you are satisfied that you won’t get back a value, you can type <code>control</code>+<code>c</code> to cancel the current function.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>λ fix (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Interrupted</span><span class="op">.</span></span></code></pre></div>
<p>The trick to <code>fix</code> is that, sometimes, it can give back a result. It can do that when the final value that you get back out doesn’t depend on any particular input value. For example, if we use the <code>const</code> function, which ignores any argument passed into it and just returns a value, then we can get a result from <code>fix</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>λ fix (<span class="fu">const</span> <span class="st">&quot;hello, haskell&quot;</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello, haskell&quot;</span></span></code></pre></div>
<p>Ignoring the question of <em>how this could possibly work</em>, it makes sense. The definition of a fixed point of a function is that it’s a value that, when passed into a function, causes the function to return that same value. This is exactly what <code>const</code> does- ignores its input and returns some value:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t <span class="fu">const</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t <span class="fu">const</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span> <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> b <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>λ f <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>λ f <span class="dv">1</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;foo&quot;</span></span></code></pre></div>
<p>This means that whatever value we pass into <code>const</code> will be the fixed point of the function that it returns.</p>
<p>Outside of the mathematical definition of a fixed point, the behavior of <code>fix</code> also makes sense if we think about it in terms of laziness, and computability. We’ve already noted that because the <code>fix</code> is polymorphic, fixed itself can’t ever get a value to pass into the function it’s trying to find the fixed point of. In a strictly evaluated language, that would be a problem, but thanks to haskell’s laziness, <em>“a value we can’t ever actually compute”</em> is still something that we can work with.</p>
<p>In the case of <code>fix</code>, the parameter that it passes into its function <em>might</em> be a value that we can’t ever actually compute, but it turns that that’s actually perfectly okay so long as we never try to compute it. In other words, if the function we pass in is <em>lazy</em> in its argument, then we never try to run the impossible calculation of creating a value, and so everything works out.</p>
<h3 id="the-two-argument-conundrum">The Two-Argument Conundrum</h3>
<p>Now that you understand how <code>fix</code> can take advantage of laziness to work at all, there’s another aspect to <code>fix</code> that might trip you up reading through the documentation. Recall that the type of fix is <code>fix :: (a -&gt; a) -&gt; a</code>, but what the documentation passes in a factorial function that takes two arguments:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>λ fix (\rec n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)) <span class="dv">5</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dv">120</span></span></code></pre></div>
<p>We can factor the function out from this example and give it a name, and confirm that it does, in fact, take two arguments: <code>rec</code>, a function with type <code>(p -&gt; p)</code>, and <code>n</code>, a value of type <code>p</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>λ factorial <span class="ot">=</span> \rec n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t factorial</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> (<span class="dt">Ord</span> p, <span class="dt">Num</span> p) <span class="ot">=&gt;</span> (p <span class="ot">-&gt;</span> p) <span class="ot">-&gt;</span> p <span class="ot">-&gt;</span> p</span></code></pre></div>
<p>So that it’s a bit easier for us to talk about, let’s pick some specific type to use as we’re thinking about this. For no particular reason, let’s use <code>Int</code>, so we can let <code>factorial</code> have the type:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>There are two things that we need to remember to be able to put together how this works. The first is that it can sometimes be quite helpful for us to stop and remember that haskell functions are curried, and to think through what our type signatures really mean when we look at them.</p>
<p>We might naturally read the type <code>(Int -&gt; Int) -&gt; Int -&gt; Int</code> as <em>a function that takes a function from an Int to an Int, and an Int, returning an Int</em>. Most of the time we can get by just fine when we read our function types this way, but every once in a while it can throw us for a loop.</p>
<p>Since haskell functions are curried, a we can rewrite a function like:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>factorial <span class="ot">=</span> \rec n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>Into one that takes a single argument and returns a new function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>factorial <span class="ot">=</span> \rec <span class="ot">-&gt;</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>When we rewrite it that way, we might naturally want to describe the function as: <em>a function that takes a function from and Int to an Int, and returns a function from an Int to an Int</em>. We can rewrite our type signature to reflect this restatement of our function so that it reads:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>factorial <span class="ot">=</span> \rec <span class="ot">-&gt;</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>Looking at this rewritten type signature now, we can start to see the second important thing that we need to keep in mind. When we’re dealing with polymorphic functions that take an <code>a</code>, the <code>a</code> could be <em>anything</em>, including a function. If we replace the <code>a</code> type parameters with <code>(Int -&gt; Int)</code> then the type of fix would become:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fixFactorial ::</span> ((<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span></code></pre></div>
<p>Or, if we let ghci render the type for us without any unnecessary parentheses:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>fix <span class="op">@</span>(<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)<span class="ot"> ::</span> ((<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>In the next section we’ll take a look at how <code>fix</code> is actually implemented. Once you’ve had a chance to see the implementation, we’ll come back to both the type of fix and how it works with laziness and put all of that knowledge together into a more cohesive understanding of how it actually works.</p>
<h2 id="implementing-fix">Implementing fix</h2>
<p>For all of the discussion about how <code>fix</code> works, its implementation is remarkably short. Whenever we find ourselves facing something completely unknown in haskell, we can start by looking at the types, and the next step is often to read the source code. [The source code for fix](https://hackage.haskell.org/package/base-4.15.0.0/docs/src/Data-Function.html#fix is available on hackage, and it’s quite short:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> f x <span class="kw">in</span> x</span></code></pre></div>
<p>Let’s walk through what’s happening here and see if we can get a handle on it. We start with a parameter, <code>f</code>, which is whatever function we want to find the fixed point for.</p>
<p>Next, we create a <em>recursive let binding</em> where we define <code>x</code> to be the result of applying <code>f</code> to <code>x</code>. This recursive let binding is the magic behind how the fixed point calculation works.</p>
<p>When we first call <code>fix</code> and create the let binding where we define <code>x</code>, we know that it has to have the <em>type</em> a, and a value that, when it’s needed, will be computed by the expression <code>f x</code>.</p>
<p>The <code>x</code> in that computation, likewise, isn’t a value yet. It’s a <em>thunk</em> that, <em>if</em> it is evaluated, will be computed by calling <code>f x</code>. In other words, we start with:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="co">{- &lt;some unevaluated thunk&gt; -}</span> <span class="kw">in</span> x</span></code></pre></div>
<p>If whoever calls this function decides they need the value of <code>x</code>, then they’ll get:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> f <span class="co">{- &lt;some unevaluated thunk&gt; -}</span> <span class="kw">in</span> x</span></code></pre></div>
<p>If <code>f</code> is a function like <code>const</code> that always returns a value without ever looking at its input value, then <code>x</code> will get set to that value and can be evaluated without any issues at all.</p>
<p>On the other hand, if <code>f</code> does need to evaluate <code>x</code>, like when we tried to pass in <code>(+1)</code>, we’ll end up with a computation that can never complete, because each time we try to look at <code>x</code> we’ll get back another layer of <em>some unevaluated thunk</em>. On the surface, this might seem to be a bit limited. After all, if we need to pass in a function that always returns a value and never looks at its input, we’re limited to permutations of <code>const</code> and not much else, unless we can get some data to work with from somewhere else…</p>
<h2 id="tying-the-knot">Tying The Knot</h2>
<p>The <code>fix</code> function doesn’t require a function that <em>never</em> evaluates its argument in order to eventually give us back a value. Instead, we need to give it a function that <em>eventually</em> doesn’t evaluate its argument. The one-word difference here between <em>never</em> and <em>eventually</em> is the difference between a computation that terminates and is well-defined, and one that is <code>undefined</code>. This is where passing a function of two parameters into fix comes into play. When we have a function like <code>(Int -&gt; Int)</code> there’s no option except for the input value that we’re given to decie <em>when</em> to terminate, so we always have to evaluate it. On the other hand, a function with the type <code>(Int -&gt; Int) -&gt; (Int -&gt; Int)</code> has much more flexibility. To see how, let’s go back to our definition of <code>factorial</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>factorial rec <span class="ot">=</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>In this factorial function, we’re taking a parameter, <code>rec :: Int -&gt; Int</code>, but we only ever evaluate it if <code>n</code> is greater than 1. Since <code>n</code> decreases with each step, we know that it will eventually reach 1 (assuming we started with a positive number), and so we know that <code>rec</code> will eventually not be evaluated, and we can return a good value.</p>
<p>When we look at this deeply we can see that this is actually a really interesting approach- we’re taking advantage of laziness so that we can return a function that only causes a value in its closure to be evaluated when the input to the returned function is sufficiently high. It’s almost like we’re passing information backwards through time, but in fact we’re simply making use of the behavior of lazy evaluation and the call stack to propagate information back and eventually resolve some thunks that have been hanging out patiently waiting around for us to allow them to be computed.</p>
<p>As a final exercise, let’s walk through the example step by step to get a much better idea of what’s happening when we make use of <code>fix</code>.</p>
<h2 id="fixing-the-factorial">Fixing The Factorial</h2>
<p>We’ll start our manual evaluation by defining two functions:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial' ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>factorial' rec <span class="ot">=</span> \n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>factorial <span class="ot">=</span> fix factorial'</span></code></pre></div>
<p>In ghci we’ll start by calling <code>factorial</code> with <code>5</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>λ factorial <span class="dv">5</span></span></code></pre></div>
<p>We can expand this to:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>fix (\rec n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> rec (n <span class="op">-</span> <span class="dv">1</span>)) <span class="dv">5</span></span></code></pre></div>
<p>And that, in turn, becomes:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="ot">=</span> (\rec n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> rec (n <span class="op">-</span> <span class="dv">1</span>)) x <span class="kw">in</span> x <span class="dv">5</span></span></code></pre></div>
<p>If we apply this function to 5, and replace <code>n</code> with <code>5</code> we end up with:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="ot">=</span> (\rec <span class="dv">4</span> <span class="ot">-&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="dv">5</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> rec (<span class="dv">5</span> <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  ) x</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> x <span class="dv">5</span></span></code></pre></div>
<p>Following the pattern until we get to our base case, we have:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="ot">=</span> (\rec <span class="dv">5</span> <span class="ot">-&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">5</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">5</span> <span class="op">*</span> rec (<span class="dv">5</span> <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec' <span class="dv">4</span> <span class="ot">-&gt;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">4</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">5</span> <span class="op">*</span> rec' (<span class="dv">4</span> <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec'' <span class="dv">3</span> <span class="ot">-&gt;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">3</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">3</span> <span class="op">*</span> rec'' (<span class="dv">3</span> <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec''' <span class="dv">2</span> <span class="ot">-&gt;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">2</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">2</span> <span class="op">*</span> rec''' (<span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\_rec <span class="dv">1</span> <span class="ot">-&gt;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">1</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="co">{- never evaluated #-}</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> x <span class="op">$</span> <span class="dv">5</span></span></code></pre></div>
<p>Once we finally hit the case where <code>n == 1</code> and we stop evaluating <code>rec</code> we can start to resolve the stack of calls in reverse order, so <code>rec'''</code> becomes <code>1</code> and we get:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="ot">=</span> (\rec <span class="dv">5</span> <span class="ot">-&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">5</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">5</span> <span class="op">*</span> rec (<span class="dv">5</span> <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec' <span class="dv">4</span> <span class="ot">-&gt;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">4</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">5</span> <span class="op">*</span> rec' (<span class="dv">4</span> <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec'' <span class="dv">3</span> <span class="ot">-&gt;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">3</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">3</span> <span class="op">*</span> rec'' (<span class="dv">3</span> <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec''' <span class="dv">2</span> <span class="ot">-&gt;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">2</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> x <span class="op">$</span> <span class="dv">5</span></span></code></pre></div>
<p>Which becomes:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="ot">=</span> (\rec <span class="dv">5</span> <span class="ot">-&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">5</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">5</span> <span class="op">*</span> rec (<span class="dv">5</span> <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec' <span class="dv">4</span> <span class="ot">-&gt;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">4</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">5</span> <span class="op">*</span> rec' (<span class="dv">4</span> <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>          ) <span class="op">$</span> (\rec'' <span class="dv">3</span> <span class="ot">-&gt;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">3</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> x <span class="op">$</span> <span class="dv">5</span></span></code></pre></div>
<p>And so on until we finally get to:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="ot">=</span> (\_ <span class="dv">5</span> <span class="ot">-&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="dv">5</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> x <span class="op">$</span> <span class="dv">5</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>In this post you’ve learned how the <code>fix</code> function from <code>Data.Function</code> relies on important features of haskell, like laziness and recursive let bindings, to provide us with a way of doing automatic recursion without having to ever directly make a recursive call. By understanding how haskell’s type system, currying, and lazy evaluation work together, and taking time to sympathize with the compiler and better understand how expressions are evaluated, you can start to see precisely how some of the more interesting, and at first more intimidating, areas of haskell work.</p>
  </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
