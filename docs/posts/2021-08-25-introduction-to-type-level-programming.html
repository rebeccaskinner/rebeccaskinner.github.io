<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Rebecca Skinner - An Introduction to Type Level Programming</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="icon" type="impage/png" href="../favicon.png">

        <meta property="og:type" content="article" />
        <meta property="og:site_name" content="RebeccaSkinner.net" />
        <meta property="og:image" content="https://rebeccaskinner.net/images/site-image-banner.png" />
        <meta property="og:title" content="An Introduction to Type Level Programming" />

        
        <meta property="og:article:published_time" content="August 25, 2021" />
        

        

        
        <meta property="og:description" content="Learn about type level programming by building a custom theming engine." />
        


    </head>
    <body>
        <header>
          <div class="logo">
            <a href="../">Rebecca Skinner</a>
          </div>
            <nav>
              <a href="../resume.html">Resume</a>
              <a href="https://github.com/rebeccaskinner/">Github</a>
              <a href="https://twitter.com/cercerilla">Twitter</a>
              <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>An Introduction to Type Level Programming</h1>
            <article>
  <section class="header">
    Posted on August 25, 2021
    
    by Rebecca Skinner
    
  </section>
  <section>
    <h2 id="prelude">Prelude</h2>
<p>This blog post is a long-form article based on a talk I delivered at the <a href="https://haskell.ove">haskell.love conference</a> on 10 Sept 2021. Keep an eye out here and I will update this section with a link to the recording of the talk when it’s available.</p>
<p>The original slides for this talk <a href="https://github.com/rebeccaskinner/presentations/blob/master/intro-to-type-level-programming/presentation.pdf">are available on github</a> along with <a href="https://github.com/rebeccaskinner/presentations/tree/master/intro-to-type-level-programming/example">the complete source code for the examples used in this article and the talk</a>.</p>
<h2 id="an-introduction-to-type-level-programming">An Introduction to Type-Level Programming</h2>
<p>Type-level programming in haskell (and other languages that support it) can be quite useful from time to time, but I find that it’s something that a lot of people struggle with learning. In haskell specifically, I think learning how to use type-level programming appropriately can be quite hard because the best real-world examples of type-level programming often come from larger projects, and it can be hard to figure out how to grow the design of your own code to make use of type level programming effectively when you’re only seeing the end-state of projects that have already grown into type level programming.</p>
<p>Outside of real-world projects, there are some well written pieces that describe various aspects of type level programming, but few references that are both accessible to people first trying to dip their toes into the world of type level programming and which also address the various approaches you can take to programming with types holistically.</p>
<p>In this article you’ll learn how to build programs that make heavy use of type-level programming by working through building a theming system. I originally developed the ideas behind this talk and article when trying to write something to unify the various themes and configurations for my own xmonad desktop setup, but the theming system you’ll build as you work through this article can be equally applied to theming web content, desktop or command line applications, or really anything that needs configurable theming.</p>
<h2 id="building-a-theming-system-at-runtime">Building A Theming System at Runtime</h2>
<p>Before we dive into building a theming system at the type-level, let’s look at a small example of what a runtime theming system might look like. Without any particular work, we might start by simply defining some records that collect information about the look and feel of various components in our system. For example, in an XMonad desktop configuration we might want to configure both the look and feel of the text we send to polybar.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  polybarColorScheme <span class="ot">=</span> <span class="dt">PolybarColorScheme</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    { focusedWorkspaceText        <span class="ot">=</span> <span class="st">&quot;#dda0dd&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    , focusedWorkspaceBackground  <span class="ot">=</span> <span class="st">&quot;#2a2035&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    , visibleWorkspaceText        <span class="ot">=</span> <span class="st">&quot;#dda0dd&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    , visibleWorkspaceBackground  <span class="ot">=</span> <span class="st">&quot;#2a2035&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>In this examples we’ve got a record with some fields and we’re setting them to strings that hold hex values. This approach is very low-effort and in a lot of cases it might be good enough, but if we wanted to be nit-picky we could note that using string values here introduces the problem that we could use invalid values and wouldn’t necessarily find out until runtime when things look wrong, or worse, crash. The first refactor that we might come up with is to try to use something other than strings to hold color data.</p>
<p>We can start by creating a new record, <code>RGB</code> that will hold each color channel. We’ll use <code>Word8</code> since it’s limited to values from 0-255, which is exactly what we want if we want to represent things using the usual 24-bit colors that we’re used to seeing.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Color</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Word</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RGB</span> <span class="ot">=</span> <span class="dt">RGB</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> rgbRed   ::</span> <span class="dt">Word8</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> rgbGreen ::</span> <span class="dt">Word8</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> rgbBlue  ::</span> <span class="dt">Word8</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>And we can refactor our original code to make use of our new type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  polybarColorScheme <span class="ot">=</span> <span class="dt">PolybarColorScheme</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    { focusedWorkspaceText        <span class="ot">=</span> <span class="dt">RGB</span> <span class="bn">0xdd</span> <span class="bn">0xa0</span> <span class="bn">0xdd</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    , focusedWorkspaceBackground  <span class="ot">=</span> <span class="dt">RGB</span> <span class="bn">0x2a</span> <span class="bn">0x20</span> <span class="bn">0x35</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    , visibleWorkspaceText        <span class="ot">=</span> <span class="dt">RGB</span> <span class="bn">0xdd</span> <span class="bn">0xa0</span> <span class="bn">0xdd</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    , visibleWorkspaceBackground  <span class="ot">=</span> <span class="dt">RGB</span> <span class="bn">0x2a</span> <span class="bn">0x20</span> <span class="bn">0x35</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Great! with one relatively small change, we’ve just eliminated a huge number of potential errors caused accidentally setting a color to some invalid string.</p>
<h3 id="the-update-problem">The Update Problem</h3>
<p>We’ve fixed the issue of potentially using invalid color strings, but we have another problem. Imagine if we wanted to make the color of our text a little bit darker, or we wanted to change the look and feel of our theme to be uniformly a bit more blue. We need to track down and change every single place where we’re using a color, throughout the entire project, and update them. If you are anything like me, this will be the start of a long process of forgetting to update things here and there and only noticing days later when you realize something <em>just doesn’t look right</em>.</p>
<p>One way to address this is to use a color palette. In fact, when we think of theming, some variation of a color palette is usually what we have in mind. For our purposes, a color palette is just any sort of a mapping between <em>names</em> and <em>colors</em>.</p>
<p>The simplest way to define a color palette would be to just create a newtype wrapper around a Map. We’ll name ours <code>ThemeInstance</code>, since what we’re really talking about is to create some specific instance or implementation of our theme.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> mapping</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ThemeInstance</span> <span class="ot">=</span> <span class="dt">ThemeInstance</span> {<span class="ot"> getThemeInstance ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">RGB</span> }</span></code></pre></div>
<p>Let’s look at an example of what it might look like to create a color palette and use it to define our polybar color scheme:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>myTheme <span class="ot">=</span> <span class="dt">ThemeInstance</span> <span class="op">.</span> Map.fromList <span class="op">$</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  [ (<span class="st">&quot;foreground&quot;</span>, <span class="dt">RGB</span> <span class="bn">0x3a</span> <span class="bn">0x20</span> <span class="bn">0x35</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;background&quot;</span>, <span class="dt">RGB</span> <span class="bn">0xdd</span> <span class="bn">0xa0</span> <span class="bn">0xdd</span>) ]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">polybarColorScheme ::</span> <span class="dt">ThemeInstance</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">PolybarColorScheme</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>polybarColorScheme (<span class="dt">ThemeInstance</span> theme) <span class="ot">=</span> <span class="dt">PolybarColorScheme</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;$&gt;</span> Map.lookup <span class="st">&quot;foreground&quot;</span> theme</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;*&gt;</span> Map.lookup <span class="st">&quot;background&quot;</span> theme</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;*&gt;</span> Map.lookup <span class="st">&quot;foreground&quot;</span> theme</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;*&gt;</span> Map.lookup <span class="st">&quot;background&quot;</span> theme</span></code></pre></div>
<h3 id="supporting-multiple-color-types">Supporting Multiple Color Types</h3>
<p>So far we’ve only thought about supporting RGB colors. As far as defaults go this is a pretty good one, and if we were going to limit ourselves to a single way to represent a color RGB is probably the way to go. That said, it would be convenient to be able to support other representations of color as well. For example, if you are using this theming system for a desktop environment, it might be convenient to easily be able to refer to <a href="https://gitlab.freedesktop.org/xorg/app/rgb/raw/master/rgb.txt">all of the the X11 colors</a> by name, even though they will eventually be represented as RGB values.</p>
<p>One way that we can approach this is to create a new typeclass for colors that we can represent as an RGB color. Let’s make one and call it <code>IsColor</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IsColor</span> a <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  toRGB ::</span> a <span class="ot">-&gt;</span> <span class="dt">RGB</span></span></code></pre></div>
<p>Creating an instance for <code>RGB</code> colors is pretty trivial:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> <span class="dt">RGB</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  toRGB <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>And if we wanted to define some types to represent our X11 colors, we can also do that pretty easily by hard-coding the RGB color associated with each of the named X11 colors:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AliceBlue</span> <span class="ot">=</span> <span class="dt">AliceBlue</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> <span class="dt">AliceBlue</span> <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  toRGB <span class="ot">=</span> <span class="fu">const</span> <span class="op">$</span> <span class="dt">RGB</span> <span class="bn">0xF0</span> <span class="bn">0xF8</span> <span class="bn">0xFF</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- many other colors omitted for brevity</span></span></code></pre></div>
<p>Now we have a bit of a problem though. We can write functions that work over anything that is a color:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toHex ::</span> <span class="dt">IsColor</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>toHex a <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (<span class="dt">RGB</span> r g b) <span class="ot">=</span> toRGB a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> printf <span class="st">&quot;%02x%02x%02x&quot;</span> r g b</span></code></pre></div>
<p>But what about our <code>ThemeInstance</code>? One option would be to add a type parameter:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ThemeInstance</span> colorType <span class="ot">=</span> <span class="dt">ThemeInstance</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> getThemeInstance ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> colorType }</span></code></pre></div>
<p>If we did that, we’d run into two problems:</p>
<ol type="1">
<li>Now, everywhere that we want to use <code>ThemeInstance</code> we need to add a constraint <code>IsColor colorType =&gt; ThemeInstance colorType</code></li>
<li>We can’t mix and match different types of colors in a single theme.</li>
</ol>
<p>Thankfully, we can solve both of those problems by creating an <em>Existential Type</em>. An <em>Existential Type</em> is a type that we can create to hold values of several different types that all implement a particular typeclass. Let’s create one called <code>SomeColor</code> to represent things that are some type of color:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeColor</span> <span class="ot">=</span> <span class="kw">forall</span> color<span class="op">.</span> <span class="dt">IsColor</span> color <span class="ot">=&gt;</span> <span class="dt">SomeColor</span> color</span></code></pre></div>
<p>As a matter of convenience, let’s also add a <code>Show</code> instance for <code>SomeColor</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">SomeColor</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="ot">=</span> <span class="fu">show</span> <span class="op">.</span> toRGB</span></code></pre></div>
<p>If we refactor our <code>ThemeInstance</code> now, we can store all sorts of different colors in the same theme:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ThemeInstance</span> <span class="ot">=</span> <span class="dt">ThemeInstance</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> getThemeInstance ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">SomeColor</span> }</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>t <span class="ot">=</span> <span class="dt">ThemeInstance</span> <span class="op">$</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  Map.insert <span class="st">&quot;red&quot;</span> (<span class="dt">SomeColor</span> <span class="op">$</span> <span class="dt">RGB</span> <span class="dv">255</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    (Map.singleton <span class="st">&quot;blue&quot;</span> (<span class="dt">SomeColor</span> <span class="dt">AliceBlue</span>))</span></code></pre></div>
<p>You’ll notice here that we’ve had to explicitly wrap up all of our colors in a <code>SomeColor</code> constructor. If you find this to be too troublesome, you can easily create a wrapper to handle this for you:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someRGB ::</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">SomeColor</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>someRGB r g b <span class="ot">=</span> <span class="dt">SomeColor</span> <span class="op">$</span> <span class="dt">RGB</span> r g b</span></code></pre></div>
<h3 id="finishing-up-our-first-pass">Finishing Up Our First Pass</h3>
<p>The approach to theming that we’ve built so far has the nice benefit of letting us decouple the actual definitions of our colors from the logical description of what colors we might want to use, and it’s has the benefit of being pretty easy to work with.</p>
<p>Unfortunately, we also have a couple of problems: First, we’ve got the problem that our configuration might fail if we’re missing a color. Sure, we can handle it somewhat gracefully by returning <code>Nothing</code> if we fail to find a color that we need, but we’re still going to be left having to deal with it at some point. We can either crash, realize that we’ve gotten back no configuration and exit gracefully, or provide some hard-coded default theme. Second, it’s hard to avoid failure because it’s not clear without reading the source code what theme elements any particular function might want to use.</p>
<p>In the next section, we’ll look at how we can address both of these problems by moving some of our theming code into the type level.</p>
<h2 id="requiring-theme-elements-at-the-type-level">Requiring Theme Elements at the Type Level</h2>
<p>The first refactor we’ll make to our code will let us address the problem of understanding what particular parts of a theme any given function might use. It will also take us one step further along the path toward total type safety for our theming system.</p>
<p>Here’s what we’re going to aim for with these refactors:</p>
<ol type="1">
<li>Let’s make sure that any function that uses a theme has a type that tells us what elements from the theme it’s using.</li>
<li>Let’s make it a compile-time error to pass a theme to a function if the theme doesn’t provide the colors that the function needs.</li>
</ol>
<p>Before we get into building this, we’ll start by taking a quick look at where we’d like to end up. This <code>colorDemo</code> function will print out a thruple of the red, green, and blue colors provided by our theme.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>colorDemo</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> ( <span class="dt">HasColor</span> <span class="st">&quot;red&quot;</span> theme</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HasColor</span> <span class="st">&quot;green&quot;</span> theme</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HasColor</span> <span class="st">&quot;blue&quot;</span> theme )</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">ThemeInstance</span> theme <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>colorDemo theme <span class="ot">=</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> r <span class="ot">=</span> lookupColor <span class="op">@</span><span class="st">&quot;red&quot;</span> theme</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>      g <span class="ot">=</span> lookupColor <span class="op">@</span><span class="st">&quot;green&quot;</span> theme</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">=</span> lookupColor <span class="op">@</span><span class="st">&quot;blue&quot;</span> theme</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="fu">show</span> (r,g,b)</span></code></pre></div>
<p>In this demo you can see we’re calling <code>lookupColor</code> using a visible type application, which we’ve enabled using the <code>TypeApplications</code> extension. For each of the colors we’ve used a visible type application for, we’re also getting a <code>HasColor</code> constraint in the type signature telling us that we need that color to be a part of our theme instance. Importantly, although we’ve added the type signature here for the sake of readability, the compiler can also infer this type for us. Being able to infer the type is helpful because it means that we can get nicer type errors if we change something.</p>
<p>If you’re not familiar with visible type applications, this extension allows us to manually tell the compiler what type to use whenever we’re dealing with some polymorphic type. For example, consider the <code>read</code> function. <code>read</code> is polymorphic and it decides how to parse a string based on the type of value it’s expected to return. Often times we end up awkwardly using type annotations to tell the compiler what type we’d like it to use:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>λ (<span class="fu">read</span> <span class="st">&quot;1&quot;</span>)<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>λ (<span class="fu">read</span> <span class="st">&quot;1&quot;</span>)<span class="ot"> ::</span> <span class="dt">Double</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span></span></code></pre></div>
<p>With visible type applications we can pass the type we’d like to use directly to the function using an <code>@</code> symbol. For example:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>λ <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>λ <span class="fu">read</span> <span class="op">@</span><span class="dt">Double</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span></span></code></pre></div>
<p>When you’re writing your own functions to be used with type applications, it’s helpful to use <strong>forall</strong> to be explicit about your type variables, since the order of variables will determine the order of type applications. Let’s look at how this works in practice:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="kw">forall</span> b a<span class="op">.</span> (<span class="dt">Read</span> a, <span class="dt">Read</span> b) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (a,b)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>f s <span class="ot">=</span> (<span class="fu">read</span> s, <span class="fu">read</span> s)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>λ f <span class="op">@</span><span class="dt">Int</span> <span class="op">@</span><span class="dt">Double</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>(<span class="fl">1.0</span>,<span class="dv">1</span>)</span></code></pre></div>
<p>In this example <code>b</code> is getting the type <code>Int</code>, and <code>a</code> is getting the type <code>Double</code>.</p>
<p>We’ll be making heavy use of type applications throughout the rest of this article, as they are often the most ergonomic way to write code that makes heavy use of type-level programming.</p>
<h3 id="refactoring-themeinstance">Refactoring ThemeInstance</h3>
<p>Now that we’ve seen a demo of where we’d like to end up, we’ll start making it a reality by looking at the <code>ThemeInstance</code> type that we’re passing into <code>colorDemo</code>. This version is a little different than the version we’ve already because we’ve added a type parameter to it. This new <sub>theme</sub> parameter will need to hold the information about what colors are available in our theme.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ThemeInstance</span> theme <span class="ot">=</span> <span class="dt">ThemeInstance</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> getThemeInstance ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">SomeColor</span> }</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>Here we’ve added a new type parameter to keep track of what’s in our theme. It’s a <em>Phantom Type</em>, so we’re not actually using the type at runtime for anything. It exists purely to help us out at the type level.</p>
<p>As we’ve implemented it, <code>theme</code> right now can be any type at all. We could create values with type <code>ThemeInstance Int</code> or <code>ThemeInstance Bool</code>, or even <code>ThemeInstance Either (Int,Bool) [(String, Maybe Int, Void -&gt; a)]</code> if we wanted to. It wouldn’t change our implementation, but it would allow us to create values with types that are semantically absurd.</p>
<p>Thankfully, we can limit the sort of types that we can use when creating a <code>ThemeInstance</code> by giving it a <em>Kind Signature</em>. To use kind signatures, we have to enable the <code>KindSignatures</code> extension. Once we’ve done that, we can use familiar syntax to annotate the Kind of a type variable.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ThemeInstance</span> (<span class="ot">theme ::</span> <span class="dt">Theme</span>) <span class="ot">=</span> <span class="dt">ThemeInstance</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> getThemeInstance ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">SomeColor</span> }</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>Of course, we still need to define <code>Theme</code>. Before we do that though, let’s take a moment to look into Kinds in general and learn a little bit more about them.</p>
<h3 id="a-brief-aside-on-kinds-and-type-level-data-structures">A Brief Aside on Kinds and Type-Level Data Structures</h3>
<p>Kinds in haskell are like the “types of types”. The normal types that we work with in everyday haskell code, like <code>Int</code> or <code>a -&gt; a</code> all have the kind <code>Type</code>. Type constructors like <code>Maybe</code> have the kind <code>Type -&gt; Type</code>. By default ghci will use <code>*</code> in place of <code>Type</code>, but for clarity in this article we’ll disable that by setting <code>NoStarisType</code>.</p>
<p>You can use ghci to look at the Kind of a Type with the <code>:kind!</code> command:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>set <span class="op">-</span><span class="dt">XNoStarIsType</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Int</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Int</span><span class="ot"> ::</span> <span class="dt">Type</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Maybe</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Maybe</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Either</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Either</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Either</span> <span class="dt">String</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> <span class="dt">String</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Either</span> <span class="dt">String</span></span></code></pre></div>
<p>The extra <code>!</code> we’re adding in <code>:kind!</code> asks ghci to give us not only the Kind of the Type, but also the “normalized type”. You’ll learn more about what that means later on in this article, but for now it’s helpful to just get in the practice of using the punctuation.</p>
<p>The syntax for creating kinds is the same as the syntax for creating new haskell types, and in fact we can reuse the same code to create both new types and kinds by enabling the <code>DataKinds</code> extension. Before we dive into creating a <code>Theme</code> kind, let’s look at a few other examples to get comfortable for what it means to create a new Kind.</p>
<p>We can start by looking at a simple example in ghci:</p>
<p>First, we’ll enable the <code>DataKinds</code> language extension, and create a new type named <code>Example</code> with a single constructor <code>MakeExample</code>. The names here are arbitrary, but if you are following along it’s a good idea to use a different name for the type and the constructor so that you’ll have an easier time following along with the output of the examples.</p>
<p>If we look at the type of <code>MakeExample</code>, as we’d expect it’s <code>Example</code>. This is just normal value level haskell code.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>set <span class="op">-</span><span class="dt">XDataKinds</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>λ <span class="kw">data</span> <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">MakeExample</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t <span class="dt">MakeExample</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="dt">MakeExample</span><span class="ot"> ::</span> <span class="dt">Example</span></span></code></pre></div>
<p>Similarly, if we look at the Kind of <code>Example</code> we’ll see that it’s a normal haskell <code>Type</code> (remember, in ghci you might see this written as <code>*</code>):</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind <span class="dt">Example</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Example</span><span class="ot"> ::</span> <span class="dt">Type</span></span></code></pre></div>
<p>Where things will start to get a bit different is if you look at the Kind of <code>MakeExample</code>. When we do this, we’re no longer treating <code>MakeExample</code> as a constructor, but rather as a type all on it’s own</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind <span class="dt">MakeExample</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MakeExample</span><span class="ot"> ::</span> <span class="dt">Example</span></span></code></pre></div>
<p>This works because the <code>DataKinds</code> extension allows us to promote data types to the type-level. When we do this, the data type becomes a Kind, and all of the constructors become types with that Kind.</p>
<p>Let’s look at another example:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>λ <span class="kw">data</span> <span class="dt">ExampleColor</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Red</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Red</span><span class="ot"> ::</span> <span class="dt">ExampleColor</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">'Red</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Green</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Green</span><span class="ot"> ::</span> <span class="dt">ExampleColor</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">'Green</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Blue</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Blue</span><span class="ot"> ::</span> <span class="dt">ExampleColor</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">'Blue</span></span></code></pre></div>
<p>Here we’re creating a sum type with constructors <code>Red</code>, <code>Green</code> and <code>Blue</code>, but thanks to <code>DataKinds</code> we’re <em>also</em> creating a new Kind with <em>types</em> <code>Red</code>, <code>Green</code> and <code>Blue</code>. You’ll notice in this example when we look at the Kind of these types, they are prefixed with a tick mark: <code>'Blue</code>. This is a way that we can differentiate between the value-level and type-level versions of things. For example, here <code>Blue</code> would be a value with the Type <code>ExampleColor</code>, but <code>'Blue</code> would be a type with the Kind <code>ExampleColor</code>. The tick marks are only required if it would otherwise be ambiguous whether you were talking about the value or type level. Since we are primarily working in the type level in this article we’ll omit the ticks, but it’s a good idea to add them in most situations to avoid unnecessary ambiguity.</p>
<p>We can see the types and kinds we’re dealing with in action by creating a typeclass. Let’s create a simple typeclass that will let us get the name of a color:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ExampleClass</span> (<span class="ot">color ::</span> <span class="dt">ExampleColor</span>) <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  sayColor ::</span> <span class="dt">String</span></span></code></pre></div>
<p>We’re using a king signature here to ensure that <code>color</code> must have the kind <code>ExampleColor</code>, so we can crate instances for <code>Red</code>, <code>Green</code>, and <code>Blue</code> as we’d expect:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ExampleClass</span> <span class="dt">Red</span> <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  sayColor <span class="ot">=</span> <span class="st">&quot;red&quot;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ExampleClass</span> <span class="dt">Green</span> <span class="kw">where</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  sayColor <span class="ot">=</span> <span class="st">&quot;green&quot;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ExampleClass</span> <span class="dt">Blue</span> <span class="kw">where</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  sayColor <span class="ot">=</span> <span class="st">&quot;blue&quot;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>λ (sayColor <span class="op">@</span><span class="dt">Red</span>, sayColor <span class="op">@</span><span class="dt">Green</span>, sayColor <span class="op">@</span><span class="dt">Blue</span>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;red&quot;</span>,<span class="st">&quot;green&quot;</span>,<span class="st">&quot;blue&quot;</span>)</span></code></pre></div>
<p>If we try to create an instance for some other type, we’ll get an error:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ExampleClass</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  sayColor <span class="ot">=</span> <span class="st">&quot;int&quot;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">56</span><span class="op">:</span><span class="dv">23</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">Expected</span> kind ‘<span class="dt">ExampleColor</span>’, but ‘<span class="dt">Int</span>’ has kind ‘<span class="dt">Type</span>’</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘<span class="dt">ExampleClass</span>’, namely ‘<span class="dt">Int</span>’</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> the <span class="kw">instance</span> declaration for ‘<span class="dt">ExampleClass</span> <span class="dt">Int</span>’</span></code></pre></div>
<p>One of the really powerful features of using <code>DataKinds</code> is that you aren’t limited to simple sum types, we can also promote data structures to the type level. For example, we can create a type level list. For example:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Empty</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Cons</span> <span class="dt">Red</span> (<span class="dt">Cons</span> <span class="dt">Green</span> (<span class="dt">Cons</span> <span class="dt">Blue</span> <span class="dt">Empty</span>))</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Cons</span> <span class="dt">Red</span> (<span class="dt">Cons</span> <span class="dt">Green</span> (<span class="dt">Cons</span> <span class="dt">Blue</span> <span class="dt">Empty</span>))<span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">ExampleColor</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">'Cons</span> <span class="dt">'Red</span> (<span class="dt">'Cons</span> <span class="dt">'Green</span> (<span class="dt">'Cons</span> <span class="dt">'Blue</span> <span class="dt">'Empty</span>))</span></code></pre></div>
<p>We can even use infix type level operators if we’d like:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> a <span class="op">:+:</span> b <span class="ot">=</span> <span class="dt">Cons</span> a b</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">6</span> <span class="op">:+:</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Red</span> <span class="op">:+:</span> <span class="dt">Green</span> <span class="op">:+:</span> <span class="dt">Blue</span> <span class="op">:+:</span> <span class="dt">Empty</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Red</span> <span class="op">:+:</span> <span class="dt">Green</span> <span class="op">:+:</span> <span class="dt">Blue</span> <span class="op">:+:</span> <span class="dt">Empty</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">ExampleColor</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">'Red</span> <span class="op">:+:</span> (<span class="dt">'Green</span> <span class="op">:+:</span> (<span class="dt">'Blue</span> <span class="op">:+:</span> <span class="dt">'Empty</span>))</span></code></pre></div>
<p>Of course, we don’t have to define everything ourselves from scratch. There are several Kinds that are available to us by default or from the <code>GHC.TypeLits</code> module included in <code>base</code>. Let’s import <code>GHC.TypeLits</code> and explore some of the built-in capabilities we get</p>
<h4 id="type-level-naturals">Type-Level Naturals</h4>
<p>The <code>Nat</code> kind defines type-level natural numbers. We can use any positive numeric literal as a type that will have the kind <code>Nat</code>. For example:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">1</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>We can also perform some basic arithmetic at the type level:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">16</span> <span class="op">+</span> <span class="dv">4</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span> <span class="op">+</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">16</span> <span class="ot">`Div`</span> <span class="dv">4</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span> <span class="ot">`Div`</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">16</span> <span class="op">*</span> <span class="dv">4</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span> <span class="op">*</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">64</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">16</span> <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span> <span class="op">-</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">12</span></span></code></pre></div>
<p>And we can compare to see if one natural is less than, or equal to, another:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span> <span class="op">&lt;=?</span> <span class="dv">2</span>)<span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">'True</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> (<span class="dv">4</span> <span class="op">&lt;=?</span> <span class="dv">2</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">4</span> <span class="op">&lt;=?</span> <span class="dv">2</span>)<span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">'False</span></span></code></pre></div>
<p>Finally, the <code>natVal</code> function gives us a way to get a runtime value-level equivalent to a type-level natural.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">16</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">16</span>)<span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>λ natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">16</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="dv">128</span></span></code></pre></div>
<p>If you’re not familiar with it, the <code>Proxy</code> type is a simple data type that comes from the <code>Data.Proxy</code> module in <code>base</code>. It makes use of phantom types to let us carry around type information with no runtime overhead. You can use <code>Proxy</code> as we’ve done here with a type application, or you can use it with a more traditional type annotation:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>λ natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<h4 id="type-level-symbols">Type-Level Symbols</h4>
<p>The <code>Symbol</code> kind defines type-level strings, similar to how <code>Nat</code> defines type-level numbers. Not as many value-level operations on strings carry over to the type level as did for numbers, but you can append symbols together and make use of <code>SymbolVal</code> to get a string representation of a type-level Symbol:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="st">&quot;Hello, World&quot;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello, World&quot;</span><span class="ot"> ::</span> <span class="dt">Symbol</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="st">&quot;Hello, World&quot;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="st">&quot;Hello, &quot;</span> <span class="ot">`AppendSymbol`</span> <span class="st">&quot;World&quot;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello, &quot;</span> <span class="ot">`AppendSymbol`</span> <span class="st">&quot;World&quot;</span><span class="ot"> ::</span> <span class="dt">Symbol</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="st">&quot;Hello, World&quot;</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>λ symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span><span class="st">&quot;Hello, World&quot;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello, World&quot;</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span><span class="st">&quot;Hello, World&quot;</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span><span class="st">&quot;Hello, World&quot;</span><span class="ot"> ::</span> <span class="dt">String</span></span></code></pre></div>
<h4 id="type-level-lists">Type-Level Lists</h4>
<p>Finally, ghc provides us type-level lists. These work like the <code>List</code> kind that we’ve already built, but allows you to use the same syntax you’re already familiar with to construct lists at the type level.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Nat</span>]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> '[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> [<span class="st">&quot;Hello&quot;</span>,<span class="st">&quot;World&quot;</span>,<span class="st">&quot;!&quot;</span>]</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;Hello&quot;</span>,<span class="st">&quot;World&quot;</span>,<span class="st">&quot;!&quot;</span>]<span class="ot"> ::</span> [<span class="dt">Symbol</span>]</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> '[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;World&quot;</span>, <span class="st">&quot;!&quot;</span>]</span></code></pre></div>
<h3 id="working-with-a-theme">Working With a <code>Theme</code></h3>
<p>Now that you understand a bit more about type-level data structures and Kinds, we can move on and define our <code>Theme</code> kind as a type-level list collection of theme elements. Since we want to support arbitrary theme elements by name, we’ll use <code>Symbol</code> to represent individual theme elements:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Theme</span> <span class="ot">=</span> [<span class="dt">Symbol</span>]</span></code></pre></div>
<p>Now that we’ve defined <code>Theme</code> we can create a <code>ThemeInstance</code> with some colors:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>λ theme <span class="ot">=</span> <span class="dt">ThemeInstance</span> <span class="op">@</span>'[<span class="st">&quot;red&quot;</span>] <span class="op">$</span> Map.singleton <span class="st">&quot;red&quot;</span> (someRGB <span class="dv">255</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t theme</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="ot">theme ::</span> <span class="dt">ThemeInstance</span> <span class="dt">DemoTheme</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>λ theme</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="dt">ThemeInstance</span> {</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  getThemeInstance <span class="ot">=</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    fromList [( <span class="st">&quot;red&quot;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>              , <span class="dt">RGB</span> {rgbRed <span class="ot">=</span> <span class="dv">255</span>, rgbGreen <span class="ot">=</span> <span class="dv">0</span>, rgbBlue <span class="ot">=</span> <span class="dv">0</span>})]</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Of course, being able to create a <code>ThemeInstance</code> with a specified theme doesn’t help us until we can actually use that information to safely to a value.</p>
<p>If you recall earlier in this article we had a short demo of how we’d like to use our theme:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>colorDemo</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> ( <span class="dt">HasColor</span> <span class="st">&quot;red&quot;</span> theme</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HasColor</span> <span class="st">&quot;green&quot;</span> theme</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HasColor</span> <span class="st">&quot;blue&quot;</span> theme )</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">ThemeInstance</span> theme <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>colorDemo theme <span class="ot">=</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> r <span class="ot">=</span> lookupColor <span class="op">@</span><span class="st">&quot;red&quot;</span> theme</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>      g <span class="ot">=</span> lookupColor <span class="op">@</span><span class="st">&quot;green&quot;</span> theme</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">=</span> lookupColor <span class="op">@</span><span class="st">&quot;blue&quot;</span> theme</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="fu">show</span> (r,g,b)</span></code></pre></div>
<p>Now that we have a <code>ThemeInstance</code> value and have defined the <code>Theme</code> kind, the next step we’ll need to take get a color while ensuring that our theme has the right set of colors. We’re calling <code>lookupColor</code> to get the color values, so let’s start there.</p>
<p>The type for <code>lookupColor</code> is:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>lookupColor</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> colorName theme<span class="op">.</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">KnownSymbol</span> colorName</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">HasColor</span> colorName theme)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">ThemeInstance</span> theme <span class="ot">-&gt;</span> <span class="dt">RGB</span></span></code></pre></div>
<p>We have two constraints here that we’ll want to look at. Let’s start with the easy one first: <code>KnownSymbol colorName</code>. This is a constraint that says <code>colorName</code> needs to be a <code>Symbol</code>. The second constraint, <code>HasColor colorName theme</code> might look familiar from the type signature of <code>colorDemo</code>. This is a typeclass that we’ll define to ensure that a given <code>theme</code> has the desired <code>color</code>.</p>
<p>Before we get back to <code>lookupColor</code> let’s implement <code>HasColor</code>. The first thing we’ll need to do is enable <code>MultiParamTypeClasses</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span></code></pre></div>
<p>Since we’re only validating that the theme holds a color at the type level, we don’t need to add any functions to the typeclass.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasColor</span> (<span class="ot">color ::</span> <span class="dt">Symbol</span>) (<span class="ot">theme ::</span> <span class="dt">Theme</span>)</span></code></pre></div>
<p>So, how do we use this typeclass to prove that our theme has the desired color? By making sure that we only define instances of the typeclass where our desired constraint holds. Thankfully, we can use many of the same techniques to do this at the type level as we would at the value level. In particular, we’ll use inductive reasoning and pattern matching.</p>
<p>Let’s start by thinking about how we could implement a value-level equivalent to our typeclass. That will give us a good starting point that we can translate to the type level.</p>
<p>A value level function might have the type:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findColor ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>We can define two base cases for this function. One where we searched the entire list and didn’t find a match:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>findColor _ [] <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>And another where we have found the element:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>findColor color (currentColor<span class="op">:</span>colors)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> color <span class="op">==</span> currentColor <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>Finally, we can define a recursive case where we haven’t found the color yet, but we still have items we can search through in our list:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>findColor color (currentColor<span class="op">:</span>colors)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> color <span class="op">==</span> currentColor <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> findColor color colors</span></code></pre></div>
<p>When we’re writing our <code>HasColor</code> instance, we’re going to apply similar logic, but with a couple of differences. The most notable difference is that we don’t ever directly return <code>True</code> or <code>False</code>. Instead, we’ve either defined a particular instance, in which case the constraint holds, or we haven’t defined that instance and we’ll get a compile-time error.</p>
<p>So, how do we apply this to the type level? We’ll start again with our base case. Since we won’t be creating any instance for cases where we don’t have a match, we can skip the base-case where we would have returned false on an empty list, and move on to the case where we found the color in the list.</p>
<p>The first thing we’ll need to do is to get the head of our theme list. To do that we’ll need to add a couple more extensions. First, we’ll need <code>FlexibleInstances</code> so that we can use a type-level list in an instance declaration. Second, we’ll need <code>TypeOperators</code> so that we can use <code>:</code> at the type level, allowing us to pattern match and get the head of our theme list.</p>
<p>With all of our extensions enabled, we’ll end up with something like this:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Color</span> <span class="kw">where</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Theme</span> <span class="ot">=</span> [<span class="dt">Symbol</span>]</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasColor</span> (<span class="ot">color ::</span> <span class="dt">Symbol</span>) (<span class="ot">theme ::</span> <span class="dt">Theme</span>)</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (color <span class="op">~</span> current) <span class="ot">=&gt;</span> <span class="dt">HasColor</span> color (current <span class="op">:</span> rest)</span></code></pre></div>
<p>The important bit here is our instance declaration:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (color <span class="op">~</span> current) <span class="ot">=&gt;</span> <span class="dt">HasColor</span> color (current <span class="op">:</span> rest)</span></code></pre></div>
<p>We’re using an <em>equality constraint</em>, <code>(color ~ current)</code>, to make sure that the color argument to our typeclass matches the head of the theme list. We’re getting the head of the list by pattern matching, just like we’d do at the value level.</p>
<p>Before we move on to the recursive case, let’s take one more pass at our existing instance. There’s a minor refactor that we can do here that illustrates one of the other big differences between type-level programming and value-level programming: If we refer to the same variable multiple times in a typeclass instance, we are requiring that they be equal. That means that we can skip the equality constraint altogether and simply write:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasColor</span> color (color <span class="op">:</span> rest)</span></code></pre></div>
<p>Now that we’ve defined our base-case, let’s look at the recursive case. In plain English, our recursive instance needs to say “If the tail of the theme list has the color you are looking for, then the entire list has the color you are looking for”. In haskell that is:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasColor</span> color rest <span class="ot">=&gt;</span> <span class="dt">HasColor</span> color (color' <span class="op">:</span> rest)</span></code></pre></div>
<p>That’s it! We’ve defined instances for both of the cases where our color is available in our theme list, and we can leave it up to the compiler to prove that it’s true in any particular circumstance.</p>
<p>To see our handiwork, let’s write a small test function to see how the compiler can enforce our constraints for us:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testFunction ::</span> <span class="dt">HasColor</span> color theme <span class="ot">=&gt;</span> ()</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>testFunction <span class="ot">=</span> ()</span></code></pre></div>
<p>Unfortunately, this doesn’t compile! If you try to load your module up in ghci you’ll see that our function is failing due to am ambiguity check.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>HasColorDemo.hs<span class="op">:</span><span class="dv">17</span><span class="op">:</span><span class="dv">17</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">Could</span> <span class="fu">not</span> deduce (<span class="dt">HasColor</span> color0 theme0)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>      from the context<span class="op">:</span> <span class="dt">HasColor</span> color theme</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>        bound by the <span class="kw">type</span> signature for<span class="op">:</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="ot">                   testFunction ::</span> <span class="kw">forall</span> (<span class="ot">color ::</span> <span class="dt">Symbol</span>) (<span class="ot">theme ::</span> <span class="dt">Theme</span>)<span class="op">.</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">HasColor</span> color theme <span class="ot">=&gt;</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>                                   ()</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        at HasColorDemo.hs<span class="op">:</span><span class="dv">17</span><span class="op">:</span><span class="dv">17</span><span class="op">-</span><span class="dv">42</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">The</span> <span class="kw">type</span> variables ‘color0’, ‘theme0’ are ambiguous</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the ambiguity check for ‘testFunction’</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>      <span class="dt">To</span> defer the ambiguity check to use sites, enable <span class="dt">AllowAmbiguousTypes</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> the <span class="kw">type</span> signature<span class="op">:</span><span class="ot"> testFunction ::</span> <span class="dt">HasColor</span> color theme <span class="ot">=&gt;</span> ()</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a><span class="dv">17</span> <span class="op">|</span><span class="ot"> testFunction ::</span> <span class="dt">HasColor</span> color theme <span class="ot">=&gt;</span> ()</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span>                 <span class="op">^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Failed</span>, no modules loaded<span class="op">.</span></span></code></pre></div>
<p>This is another common problem you will encounter when dealing with type-level programming. The problem is that because we’re not actually using the <code>color</code> and <code>theme</code> type variables anywhere except inside of our constraint, ghc finds them to be ambiguous. We can get around this safely by turning on <code>AllowAmbiguousTypes</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></span></code></pre></div>
<p>Okay, back to the testing. If we load this up in ghci and now it will compile. When we give it a test we’ll see…</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>λ testFunction <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span>'[<span class="st">&quot;red&quot;</span>]</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">23</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">Overlapping</span> instances for <span class="dt">HasColor</span> <span class="st">&quot;red&quot;</span> '[<span class="st">&quot;red&quot;</span>]</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>        arising from a use <span class="kw">of</span> ‘testFunction’</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Matching</span> instances<span class="op">:</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">instance</span> [safe] <span class="dt">HasColor</span> color colors <span class="ot">=&gt;</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">HasColor</span> color (color' <span class="op">:</span> colors)</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Defined at HasColorDemo.hs:13:10</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">instance</span> [safe] <span class="dt">HasColor</span> color (color <span class="op">:</span> colors)</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Defined at HasColorDemo.hs:12:10</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the expression<span class="op">:</span> testFunction <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span>'[<span class="st">&quot;red&quot;</span>]</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘it’<span class="op">:</span> it <span class="ot">=</span> testFunction <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span>'[<span class="st">&quot;red&quot;</span>]</span></code></pre></div>
<p>Well that’s not what we wanted!</p>
<p>What’s happening here is that we’re taking for granted some information that the compiler can’t make use of. As you’ve learned, whenever we use the same type variable multiple times in an instance declaration we telling the compiler that those two types have to be the same. The problem here is that we can’t make the opposite assumption. In our recursive instance:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasColor</span> color rest <span class="ot">=&gt;</span> <span class="dt">HasColor</span> color (color' <span class="op">:</span> rest)</span></code></pre></div>
<p>The two type variables <code>color</code> and <code>color'</code> don’t <em>have</em> to be the same, but they <em>might be</em>. In the case that they are the same, the compiler doesn’t know which instance it should use, and so it gives us an error.</p>
<p>We can fix this by telling the compiler which instance it should prefer by adding in an <code>Overlappable</code> or <code>Overlapping</code> annotation to our typeclass instance. For now, we’ll add it to our recursive instance:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HasColor</span> color colors <span class="ot">=&gt;</span> <span class="dt">HasColor</span> color (color'<span class="op">:</span>colors)</span></code></pre></div>
<p>With this annotation in place, we’re telling the compiler <em>“hey, whenever there are two instances that might work, <strong>pick the other one</strong>”</em>.</p>
<p>Now that we’ve told ghc how to handle the overlapping instances, let’s give our test function another try:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>λ testFunction <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span>'[<span class="st">&quot;red&quot;</span>]</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>()</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>λ testFunction <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span>'[<span class="st">&quot;blue&quot;</span>]</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">5</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">HasColor</span> <span class="st">&quot;red&quot;</span> '[])</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        arising from a use <span class="kw">of</span> ‘testFunction’</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the expression<span class="op">:</span> testFunction <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span>'[<span class="st">&quot;blue&quot;</span>]</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘it’<span class="op">:</span> it <span class="ot">=</span> testFunction <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span>'[<span class="st">&quot;blue&quot;</span>]</span></code></pre></div>
<p>Finally! The return value of <code>()</code> here is not very exciting, but we can now see for ourselves how <code>HasColor</code> has helped us to ensure that we can only compile our function when we’re asking for a color that’s a member of the theme we’re passing in.</p>
<p>Now that you’ve learned how to build <code>HasColor</code> let’s return to <code>lookupColor</code> and see if we can implement it.</p>
<h3 id="implementing-lookupcolor">Implementing <code>lookupColor</code></h3>
<p>If you recall from earlier in this article, we said that the type of <code>lookupColor</code> was:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>lookupColor</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> colorName theme<span class="op">.</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">KnownSymbol</span> colorName</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">HasColor</span> colorName theme)</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">ThemeInstance</span> theme <span class="ot">-&gt;</span> <span class="dt">RGB</span></span></code></pre></div>
<p>Now that you understand both <code>KnownSymbol</code> and <code>HasColor</code> you might already have an intuition for how to implement this function: we’ll start by using <code>symbolVal</code> to get the color name, which will be the key to our theme map. Then we’ll get that element from our map. Since our goal is to ensure that we have all of the necessary elements of our theme map at compile time, we shouldn’t need to use a safe lookup function. The unsafe function <code>Map.!</code> ought to work for us.</p>
<p>Here’s the full implementation:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>lookupColor</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> colorName theme<span class="op">.</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">KnownSymbol</span> colorName</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">HasColor</span> colorName theme)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">ThemeInstance</span> theme <span class="ot">-&gt;</span> <span class="dt">RGB</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>lookupColor (<span class="dt">ThemeInstance</span> colors) <span class="ot">=</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    targetName <span class="ot">=</span> symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>colorName</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> toRGB <span class="op">$</span> colors <span class="op">Map.!</span> targetName</span></code></pre></div>
<h3 id="a-lookup-color-demo">A Lookup Color Demo</h3>
<p>Now that we’ve defined <code>lookupColor</code> let’s test it out with a few calls in ghci.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>λ <span class="kw">type</span> <span class="dt">DemoTheme</span> <span class="ot">=</span> '[<span class="st">&quot;red&quot;</span>, <span class="st">&quot;green&quot;</span>, <span class="st">&quot;blue&quot;</span>]</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>{</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">ThemeExample</span><span class="op">|</span> theme <span class="ot">=</span> <span class="dt">ThemeInstance</span> <span class="op">@</span><span class="dt">DemoTheme</span> <span class="op">$</span> Map.fromList</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">ThemeExample</span><span class="op">|</span>   [ (<span class="st">&quot;red&quot;</span>, someRGB <span class="dv">255</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">ThemeExample</span><span class="op">|</span>   , (<span class="st">&quot;green&quot;</span>, someRGB <span class="dv">0</span> <span class="dv">255</span> <span class="dv">0</span>)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">ThemeExample</span><span class="op">|</span>   , (<span class="st">&quot;blue&quot;</span>, someRGB <span class="dv">0</span> <span class="dv">0</span> <span class="dv">255</span>) ]</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">ThemeExample</span><span class="op">|</span> <span class="op">:</span>}</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>λ lookupColor <span class="op">@</span><span class="st">&quot;red&quot;</span> theme</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="dt">RGB</span> {rgbRed <span class="ot">=</span> <span class="dv">255</span>, rgbGreen <span class="ot">=</span> <span class="dv">0</span>, rgbBlue <span class="ot">=</span> <span class="dv">0</span>}</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>λ lookupColor <span class="op">@</span><span class="st">&quot;green&quot;</span> theme</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="dt">RGB</span> {rgbRed <span class="ot">=</span> <span class="dv">0</span>, rgbGreen <span class="ot">=</span> <span class="dv">255</span>, rgbBlue <span class="ot">=</span> <span class="dv">0</span>}</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>λ lookupColor <span class="op">@</span><span class="st">&quot;blue&quot;</span> theme</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a><span class="dt">RGB</span> {rgbRed <span class="ot">=</span> <span class="dv">0</span>, rgbGreen <span class="ot">=</span> <span class="dv">0</span>, rgbBlue <span class="ot">=</span> <span class="dv">255</span>}</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>λ lookupColor <span class="op">@</span><span class="st">&quot;yellow&quot;</span> theme</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">19</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">HasColor</span> <span class="st">&quot;yellow&quot;</span> '[])</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>        arising from a use <span class="kw">of</span> ‘lookupColor’</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the expression<span class="op">:</span> lookupColor <span class="op">@</span><span class="st">&quot;yellow&quot;</span> theme</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘it’<span class="op">:</span> it <span class="ot">=</span> lookupColor <span class="op">@</span><span class="st">&quot;yellow&quot;</span> theme</span></code></pre></div>
<p>So far, so good. We’ve created a new theme and gotten values out of it, and we’ve even prevented a runtime error by failing at compile time when we tried to get a missing color out of the theme.</p>
<p>There’s still a problem though. Let’s look at another variation of our example:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>λ theme <span class="ot">=</span> <span class="dt">ThemeInstance</span> <span class="op">@</span><span class="dt">DemoTheme</span> Map.empty</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>λ lookupColor <span class="op">@</span><span class="st">&quot;red&quot;</span> theme</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> <span class="op">Map.!:</span> given key is <span class="fu">not</span> an element <span class="kw">in</span> the <span class="fu">map</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="dt">CallStack</span> (from <span class="dt">HasCallStack</span>)<span class="op">:</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">error</span>, called at</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  libraries<span class="op">/</span>containers<span class="op">/</span>containers<span class="op">/</span>src<span class="op">/</span><span class="dt">Data</span><span class="op">/</span><span class="dt">Map</span><span class="op">/</span>Internal.hs<span class="op">:</span><span class="dv">627</span><span class="op">:</span><span class="dv">17</span> <span class="kw">in</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>  containers<span class="op">-</span><span class="fl">0.6</span><span class="op">.</span><span class="fl">2.1</span><span class="op">:</span><span class="dt">Data.Map.Internal</span></span></code></pre></div>
<p>Oh no! In spite of all of our effort, we’ve still hit a runtime error. In the next section we’ll refactor our code a bit and you’ll learn how to avoid this pitfall.</p>
<h2 id="constructing-a-theme-instance-at-the-type-level">Constructing A Theme Instance At The Type Level</h2>
<p>In the last section, we saw that we have an error lurking in our current implementation of our type-level theming code. The problem is that we don’t have any way of ensuring that the contents of the map that we’re using to store our theme data actually matches what the type says it should be.</p>
<p>Let’s consider an alternate approach. Right now we define a Theme at the type level <em>independently</em> of adding colors to the runtime theme. What if, instead, we refactored our code so that each time we added a color value to the theme, it added that same color to the theme’s type. Even better, what if that was the only way to add colors to the theme type. That would ensure that the type of our theme instance always precisely matched the colors it actually has available.</p>
<h3 id="a-simple-gadt-approach-to-constructive-theme-building">A Simple GADT Approach To Constructive Theme Building</h3>
<p>GADTs are an extremely versatile tool that we can use for constructing values and types in haskell. They greatly extend what we can accomplish with value constructors by allowing us to easily add constraints to the parameters of a value constructor, as well as giving us the ability to create constructors that specify the full type that they return.</p>
<p>Before we jump into using a GADT for theming, let’s look at a smaller example just to get a feel for them. Imagine we want to create a value that can hold any one of an <code>Int</code>, a <code>String</code>, or a <code>Bool</code>.</p>
<p>We can already do this with normal sum types:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeValue</span> <span class="ot">=</span> <span class="dt">SomeInt</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">SomeString</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">SomeBool</span> <span class="dt">Bool</span></span></code></pre></div>
<p>The problem here is that our <code>SomeType</code> value doesn’t carry any information about what constructor we used. Any function that were going to work with any of those branches would end up having to work with all of them. For example, we might want to write a function like:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">notSomeValue ::</span> <span class="dt">SomeValue</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>notSomeValue val <span class="ot">=</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> val <span class="kw">of</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SomeInt</span> _ <span class="ot">-&gt;</span> val</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SomeString</span> _ <span class="ot">-&gt;</span> val</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SomeBool</span> b <span class="ot">-&gt;</span> <span class="dt">SomeBool</span> (<span class="fu">not</span> b)</span></code></pre></div>
<p>With GADTs we can add some additional information at the type level. Let’s start by recreating exactly what we had before using GADT syntax:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeValue'</span> <span class="kw">where</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeInt'</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue'</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeString'</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue'</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeBool'</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue'</span></span></code></pre></div>
<p>The syntax here might look a little strange at first. Instead of the normal constructors we’re accustomed to, we have a where clause and what looks like a set of functions with type annotations. In some ways, the GADT syntax looks more like the syntax for a typeclass than for a normal algebraic datatype.</p>
<p>Once you get past the initial strangeness of the new syntax though, we can see that it’s not actually all that different from what we’ve already been doing. After all, if we look up the type of our <code>SomeValue</code> constructors in ghci we’ll see type signatures that look just like the ones we’ve written:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t <span class="dt">SomeInt</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t <span class="dt">SomeInt'</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeInt'</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue'</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t <span class="dt">SomeString</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeString</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t <span class="dt">SomeString'</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="dt">SomeString'</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue'</span></span></code></pre></div>
<p>GADTs can do more than just offer a different syntax for defining types though. Since we’re writing out the type annotation for each of the constructors ourselves, we have access to much more power from the type system than we’d have when writing constructors the usual way. For example, we can easily have polymorphic constructors with typeclass constraints. Imagine if we wanted a field that supported any number. With traditional data types, we’d need to create an existential type to hold the number, but we can do it directly with GADTs:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeNumber</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SomeValue'</span></span></code></pre></div>
<p>Another key feature of GADTs is the fact that each constructor can have a unique <em>return type</em>. To demonstrate this, we’ll need to add a type parameter to our example. Let’s rewrite our original <code>SomeValue</code> type to use a GADT, and add a type parameter to it</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeValue</span> t <span class="kw">where</span></span></code></pre></div>
<p>In a traditional haskell data type, <code>t</code> would have to be independent of any particular type constructor. With a GADT though, we can control the type of each of the constructors, and so we can specialize <code>t</code> depending on which constructor is called. For example, we can set <code>t</code> to <code>Int</code>, <code>String</code>, or <code>Bool</code> depending on the constructor that’s called to generate <code>SomeValue</code>:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue</span> <span class="dt">Int</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeString</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue</span> <span class="dt">String</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeBool</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">SomeValue</span> <span class="dt">Bool</span></span></code></pre></div>
<p>The benefit here is that having this information available at the type level let’s us write much nicer code when we only want to work with a single constructor. We can rewrite <code>notSomeValue</code> now to only handle cases where we know we have a boolean value:</p>
<pre><code>notSomeValue :: SomeValue Bool -&gt; SomeValue Bool
notSomeValue (SomeBool b) = SomeBool (not b)</code></pre>
<p>Unlike or original version, we no longer need to match against all of the different <code>SomeValue</code> constructors- the fact that we’re restricting our input to <code>SomeValue Bool</code> is enough to convince both us, and the compiler, that we’ve exhaustively handled all of the cases.</p>
<p>You might be wondering how this can help us construct a type-safe theme. Let’s take a look by creating a new GADT called <code>MakeSimpleTheme</code> that will allow us to construct a simple but more type-safe theme.</p>
<p>We’ll start by defining the type. We’ll add a parameter to keep track of the current them:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MakeSimpleTheme</span> (<span class="ot">theme ::</span> <span class="dt">Theme</span>) <span class="kw">where</span></span></code></pre></div>
<p>Next, we’ll add a constructor that will allow us to create a new empty theme. Just like when we were writing <code>HasColor</code>, an empty theme is an empty type-level list, so our constructor is:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SimpleNewTheme</span><span class="ot"> ::</span> <span class="dt">MakeSimpleTheme</span> '[]</span></code></pre></div>
<p>Finally, we’ll create a recursive constructor. This will be the part that will let us build up the type that we want in our theme.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SimpleAddColor</span><span class="ot"> ::</span> (<span class="dt">KnownSymbol</span> colorName)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=&gt;</span> <span class="dt">SomeColor</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">-&gt;</span> <span class="dt">MakeSimpleTheme</span> theme</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">-&gt;</span> <span class="dt">MakeSimpleTheme</span> (colorName <span class="op">:</span> theme)</span></code></pre></div>
<p>In this example we’re using GADT’s ability to both include typeclass constraints and the ability to specialize the return type of a constructor so that we can ensure that each call to <code>SimpleAddColor</code> will result in an <code>MakeSimpleTheme</code> value with the new color name added into the list of colors that we’re tracking. Essentially, we’re constructing a type and value level list at the same time with a single call!</p>
<p>Let’s test this out: We’ll start by creating a simple theme demo. Note that we’re not adding an explicit type signature here- it will be generated for us because of the way that we’re creating our <code>MakeSimpleTheme</code> value.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MakeSimpleTheme</span> (<span class="ot">theme ::</span> <span class="dt">Theme</span>) <span class="kw">where</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SimpleNewTheme</span><span class="ot"> ::</span> <span class="dt">MakeSimpleTheme</span> '[]</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SimpleAddColor</span><span class="ot"> ::</span> (<span class="dt">KnownSymbol</span> colorName)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=&gt;</span> <span class="dt">SomeColor</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">-&gt;</span> <span class="dt">MakeSimpleTheme</span> theme</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">-&gt;</span> <span class="dt">MakeSimpleTheme</span> (colorName <span class="op">:</span> theme)</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>simpleDemo <span class="ot">=</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SimpleAddColor</span> <span class="op">@</span><span class="st">&quot;red&quot;</span> (someRGB <span class="dv">255</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">SimpleAddColor</span> <span class="op">@</span><span class="st">&quot;green&quot;</span> (someRGB <span class="dv">0</span> <span class="dv">255</span> <span class="dv">0</span>)</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>      ( <span class="dt">SimpleAddColor</span> <span class="op">@</span><span class="st">&quot;blue&quot;</span> (someRGB <span class="dv">0</span> <span class="dv">0</span> <span class="dv">255</span>) <span class="dt">SimpleNewTheme</span>))</span></code></pre></div>
<p>And indeed, if we look at the type of <code>simpleDemo</code> in ghci, we see that it has exactly the colors that we expect.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t simpleDemo</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleDemo ::</span> <span class="dt">MakeSimpleTheme</span> '[<span class="st">&quot;red&quot;</span>, <span class="st">&quot;green&quot;</span>, <span class="st">&quot;blue&quot;</span>]</span></code></pre></div>
<h3 id="creating-a-theme-instance-from-makesimpletheme">Creating A Theme Instance From MakeSimpleTheme</h3>
<p>Having a <code>MakeSimpleTheme</code> value with the correct types is a useful first step, but it doesn’t quite get us all the way to being able to theme things. The code we’ve written so far assumes that we’re working with <code>ThemeInstance</code> values. We could rewrite that code to work with <code>MakeSimpleTheme</code>, but that would break backwards compatibility and might require that we rewrite a bunch of code that’s already been tested and is working. Instead let’s add a new feature to support safer theming by creating a way to convert a <code>MakeSimpleTheme</code> into a <code>ThemeInstance</code> with an appropriate type.</p>
<p>We want to write some runtime code to generate a <code>ThemeInstance</code> based on the particular type of our <code>MakeSimpleTheme</code>, and so like most of the other problems we’ve encountered so far in this article, we’ll want to start thinking about writing a typeclass.</p>
<p>We’ll call this one <code>ToThemeInstance</code> and it will give us a way to convert some types into a <code>ThemeInstance</code> value.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ToThemeInstance</span> (<span class="ot">a ::</span> <span class="dt">Theme</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">t ::</span> <span class="dt">Theme</span>) <span class="kw">where</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  toThemeInstance ::</span> a t <span class="ot">-&gt;</span> <span class="dt">ThemeInstance</span> t</span></code></pre></div>
<p>Our typeclass has two parameters- first a type constructor that wants to take a <code>Theme</code>, and second the <code>Theme</code> that we’re working with. The type of our <code>toThemeInstance</code> function ensures that the theme being used by our input type matches the <code>ThemeInstance</code> being generated at each step.</p>
<p>As usual, our base-case is pretty straightforward. When our theme is empty, we can construct an empty theme instance using an empty map.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToThemeInstance</span> <span class="dt">MakeSimpleTheme</span> '[] <span class="kw">where</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  toThemeInstance <span class="dt">SimpleNewTheme</span> <span class="ot">=</span> <span class="dt">ThemeInstance</span> Map.empty</span></code></pre></div>
<p>Our recursive instance looks very similar to code we’ve seen already- in fact it seems to have elements of both <code>HasColor</code> and <code>lookupColor</code>. Like <code>HasColor</code> and most other recursive typeclass instances, we handle recursion at the instance level with a typeclass constraint. We’re also pattern matching to get the head of our theme list like we did in <code>HasColor</code>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ToThemeInstance</span> <span class="dt">MakeSimpleTheme</span> colors) <span class="ot">=&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ToThemeInstance</span> <span class="dt">MakeSimpleTheme</span> (color<span class="op">:</span>colors)</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span></code></pre></div>
<p>The implementation of <code>toThemeInstance</code> might bring to mind <code>lookupColor</code>. We’re going to again make use of <code>symbolVal</code> to generate a key for the current color in our theme map. The difference here is that instead of extracting the value, we’re going to insert it:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ToThemeInstance</span> <span class="dt">MakeSimpleTheme</span> colors) <span class="ot">=&gt;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ToThemeInstance</span> <span class="dt">MakeSimpleTheme</span> (color<span class="op">:</span>colors)</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>  toThemeInstance (<span class="dt">SimpleAddColor</span> rgb rest) <span class="ot">=</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (<span class="dt">ThemeInstance</span> m) <span class="ot">=</span> toThemeInstance rest</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>        colorName <span class="ot">=</span> symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>color</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> <span class="dt">ThemeInstance</span> (Map.insert colorName rgb m)</span></code></pre></div>
<p>That’s it! We can now freely create a runtime <code>ThemeInstance</code> with the correct elements and theme type by constructively creating a <code>MakeSimpleTheme</code>. Let’s take a look at a demo by converting <code>simpleDemo</code> into a <code>ThemeInstance</code>:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>t toThemeInstance simpleDemo</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>toThemeInstance simpleDemo</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">ThemeInstance</span> '[<span class="st">&quot;red&quot;</span>, <span class="st">&quot;green&quot;</span>, <span class="st">&quot;blue&quot;</span>]</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>λ toThemeInstance simpleDemo</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="dt">ThemeInstance</span> {</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>  getThemeInstance <span class="ot">=</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    fromList [ ( <span class="st">&quot;blue&quot;</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>               , <span class="dt">RGB</span> { rgbRed <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>                     , rgbGreen <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>                     , rgbBlue <span class="ot">=</span> <span class="dv">255</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>                     }</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>               )</span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>             , ( <span class="st">&quot;green&quot;</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>               , <span class="dt">RGB</span> { rgbRed <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>                     , rgbGreen <span class="ot">=</span> <span class="dv">255</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>                     , rgbBlue <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>                     }</span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>               )</span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>             , ( <span class="st">&quot;red&quot;</span></span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>               , <span class="dt">RGB</span> { rgbRed <span class="ot">=</span> <span class="dv">255</span></span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a>                     , rgbGreen <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a>                     , rgbBlue <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a>                     }</span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a>               )</span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a>             ]</span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Although it’s minor compared to the earlier problems we’ve had of potential runtime failures, there still a bit of a problem with our current implementation.</p>
<p>When we construct a theme using <code>MakeSimpleTheme</code> we’re assigning the colors at the time that we create the theme. In some circumstances this is fine, but for cases like the X11 colors, we might want to make use of existing names that are already provided for some particular colors. In the next section, we’ll explore how we can support this carrying the name and color value information around in the same type.</p>
<h2 id="colors-at-the-type-level">Colors at the Type Level</h2>
<p>Up until now, we’ve been treating the type level and runtime representations of colors quite differently. At the runtime level we’re using <code>SomeColor</code> which will let us store something that we can turn into an <code>RGB</code> value, whereas at the type level we’re storing a list of color names as <code>Symbol</code> types. In general, it would be good if we could just have a single representation of colors, rather than two separate representations.</p>
<p>For reasons you’ll see in the next section, we’ll keep <code>ThemeInstance</code> as it is, and instead focus our efforts on refactoring <code>MakeSimpleTheme</code>. Before we can refactor our theme builder though, we need to figure out how we might want to represent colors at the type level.</p>
<p>In fact, we’re already part of the way there. If you recall earlier in this article we started defining some X11 colors:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AliceBlue</span> <span class="ot">=</span> <span class="dt">AliceBlue</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> <span class="dt">AliceBlue</span> <span class="kw">where</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>  toRGB <span class="ot">=</span> <span class="fu">const</span> <span class="op">$</span> <span class="dt">RGB</span> <span class="bn">0xF0</span> <span class="bn">0xF8</span> <span class="bn">0xFF</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Plum</span> <span class="ot">=</span> <span class="dt">Plum</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> <span class="dt">Plum</span> <span class="kw">where</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>  toRGB <span class="ot">=</span> <span class="fu">const</span> <span class="op">$</span> <span class="dt">RGB</span> <span class="bn">0xDD</span> <span class="bn">0xA0</span> <span class="bn">0xDD</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RebeccaPurple</span> <span class="ot">=</span> <span class="dt">RebeccaPurple</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> <span class="dt">RebeccaPurple</span> <span class="kw">where</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>  toRGB <span class="ot">=</span> <span class="fu">const</span> <span class="op">$</span> <span class="dt">RGB</span> <span class="bn">0x66</span> <span class="bn">0x33</span> <span class="bn">0x99</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- many other colors omitted for brevity</span></span></code></pre></div>
<p>These colors are already defined at the type level. No work to do, but it does give us a clue for how we might approach a type-level RGB color.</p>
<h3 id="type-level-rgb">Type-Level RGB</h3>
<p>Our X11 colors were each standalone types, but we made them viable colors by giving creating an instance of <code>IsColor</code> for each of them. We can take the same approach for RGB colors. Unfortunately, we can’t use <code>DataKinds</code> to get an RGB color at the type level automatically, so we’ll need to define a new type. We’ll call it <code>RGBTypeLevel</code> to help avoid confusion with the runtime <code>RGB</code> type.</p>
<p>We want to have each potential RGB color be it’s own distinct type. The easiest way to do that is to add type parameters for each color channel. Since we’re dealing with numbers, we’ll make sure those types are of Kind <code>Nat</code>:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RGBTypeLevel</span> (<span class="ot">r ::</span> <span class="dt">Nat</span>) (<span class="ot">g ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>) <span class="ot">=</span> <span class="dt">RGBTypeLevel</span></span></code></pre></div>
<p>Now we can easily create a new RGB value at the type level by saying:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>λ typeLevelRed <span class="ot">=</span> <span class="dt">RGBTypeLevel</span> <span class="op">@</span><span class="dv">255</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">0</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>λ typeLevelGreen <span class="ot">=</span> <span class="dt">RGBTypeLevel</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">255</span> <span class="op">@</span><span class="dv">0</span></span></code></pre></div>
<p>or even…</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>λ typeLevelBlue <span class="ot">=</span> <span class="dt">RGBTypeLevel</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">999</span></span></code></pre></div>
<p>Wait- that’s not right! Each channel of our RGB color should be a number between 0 and 255. We better take care of that. At first we might think to try a GADT here so that we can limit the values:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RGBTypeLevel</span> (<span class="ot">r ::</span> <span class="dt">Nat</span>) (<span class="ot">g ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RGBTypeLevel</span><span class="ot"> ::</span> (r <span class="op">&lt;=</span> <span class="dv">255</span>, g <span class="op">&lt;=</span> <span class="dv">255</span>, b <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">RGBTypeLevel</span> r g b</span></code></pre></div>
<p>The <code>&lt;=</code> constraint here comes from <code>GHC.TypeLits</code> and is similar to the <code>&lt;=?</code> function that you saw earlier when you were learning about <code>Nat</code>, but it works as a constraint rather than returning a <code>Bool</code>.</p>
<p>Using a GADT with constraints to ensure the values aren’t greater than 255 will work in a lot of cases- we can’t create a value with an invalid type anymore:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>λ typeLevelBlue <span class="ot">=</span> <span class="dt">RGBTypeLevel'</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">999</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">127</span><span class="op">:</span><span class="dv">17</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">Couldn't</span> match <span class="kw">type</span> ‘<span class="dt">'False</span>’ with ‘<span class="dt">'True</span>’</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>        arising from a use <span class="kw">of</span> ‘<span class="dt">RGBTypeLevel'</span>’</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the expression<span class="op">:</span> <span class="dt">RGBTypeLevel'</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">999</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘typeLevelBlue’<span class="op">:</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>          typeLevelBlue <span class="ot">=</span> <span class="dt">RGBTypeLevel'</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">999</span></span></code></pre></div>
<p>However, we aren’t entirely protected. When we’re working at the type level, we need to also consider situations where a user might be working with the type without ever trying to create an instance of it. Imagine a typeclass called <code>GetColor</code> that gets a runtime representation of the color:</p>
<pre><code>class GetColor a where getColor :: String</code></pre>
<p>We might create an instance for <code>RGBTypeLevel</code> that seems well behaved:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">KnownNat</span> r, <span class="dt">KnownNat</span> g, <span class="dt">KnownNat</span> b) <span class="ot">=&gt;</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GetColor</span> (<span class="dt">RGBTypeLevel</span> r g b)</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  getColor <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> ( natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>r</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>                    , natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>g</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>                    , natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>b)</span></code></pre></div>
<p>Unfortunately, a user could still use this instance to get back a value that can’t be a proper RGB color. Let’s look at an example:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>λ getColor <span class="op">@</span>(<span class="dt">RGBTypeLevel</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1000</span>)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;(0,0,1000)&quot;</span></span></code></pre></div>
<p>The problem here is that constraints on a GADT only apply when we’re constructing a value. When we’re using type applications we’re never directly constructing a value so the constraints are never checked.</p>
<p>Of course, we could simply move the constraint that a color channel be less than 256 into our typeclass:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">KnownNat</span> r, <span class="dt">KnownNat</span> g, <span class="dt">KnownNat</span> b, r <span class="op">&lt;=</span> <span class="dv">255</span>, g <span class="op">&lt;=</span> <span class="dv">255</span>, b <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GetColor</span> (<span class="dt">RGBTypeLevel</span> r g b)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  getColor <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> ( natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>r</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>                    , natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>g</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>                    , natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>b)</span></code></pre></div>
<p>This does exactly what we want, preventing our users from accidentally trying to use an RGB color with values that are out of bounds.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>λ getColor <span class="op">@</span>(<span class="dt">RGBTypeLevel</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1000</span>)</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">143</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">Couldn't</span> match <span class="kw">type</span> ‘<span class="dt">'False</span>’ with ‘<span class="dt">'True</span>’</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>        arising from a use <span class="kw">of</span> ‘getColor’</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the expression<span class="op">:</span> getColor <span class="op">@</span>(<span class="dt">RGBTypeLevel</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1000</span>)</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘it’<span class="op">:</span> it <span class="ot">=</span> getColor <span class="op">@</span>(<span class="dt">RGBTypeLevel</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1000</span>)</span></code></pre></div>
<p>Unfortunately, it’s also extremely verbose. It wouldn’t be so bad if we only needed to add the constraints to a single instance, but we’ll need to apply this set of constraints anywhere that we use a typelevel RGB color.</p>
<p>Luckily for us, there’s a ghc extension for that. The <code>ConstraintKinds</code> extension allows us to treat constraints as their own Kind. This makes it convenient to create aliases for long typeclass constraints that we can reuse.</p>
<p>Let’s enable <code>ConstraintKinds</code> and then create a constraint that ensures we have some valid RGB color channels:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ValidRGB</span> r g b <span class="ot">=</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">KnownNat</span> r, r <span class="op">&lt;=</span> <span class="dv">255</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">KnownNat</span> g, g <span class="op">&lt;=</span> <span class="dv">255</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">KnownNat</span> b, b <span class="op">&lt;=</span> <span class="dv">255</span>)</span></code></pre></div>
<p>Now we can refactor our code to make use of this constraint to use our new constraint like any other:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ValidRGB</span> r g b <span class="ot">=&gt;</span> <span class="dt">GetColor</span> (<span class="dt">RGBTypeLevel</span> r g b) <span class="kw">where</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>  getColor <span class="ot">=</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> <span class="op">$</span> (natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>r, natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>g, natVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>b)</span></code></pre></div>
<p>Much better! We’ve now saved ourselves a lot of typing, made the code easier to follow, and make our constraints reusable. And since we’re going to be reusing our constraint everywhere anyway, we can revert to our simpler type definition:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RGBTypeLevel</span> (<span class="ot">r ::</span> <span class="dt">Nat</span>) (<span class="ot">g ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>) <span class="ot">=</span> <span class="dt">RGBTypeLevel</span></span></code></pre></div>
<p>And finally, now that we can create a type-level RGB value and ensure that it fits within the bounds of an 8-bit word, we can create an instance of <code>IsColor</code> for any of our (valid) RGB values:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ValidRGB</span> r g b <span class="ot">=&gt;</span> <span class="dt">IsColor</span> (<span class="dt">RGBTypeLevel</span> r g b) <span class="kw">where</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>  toRGB <span class="ot">=</span> <span class="fu">const</span> <span class="op">$</span> <span class="dt">RGB</span> (natWord8 <span class="op">@</span>r) (natWord8 <span class="op">@</span>g) (natWord8 <span class="op">@</span>b)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      natWord8 ::</span> <span class="kw">forall</span> n<span class="op">.</span> (<span class="dt">KnownNat</span> n, n <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">Word8</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>      natWord8 <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> natVal (<span class="dt">Proxy</span> <span class="op">@</span>n)</span></code></pre></div>
<h3 id="naming-things">Naming Things</h3>
<p>Now that we have a way to represent colors at the type-level, it would be nice if we could move away from having the color names and color values exist as completely separate things. We should have a way of defining colors that have their own name information associated with them.</p>
<p>What we’d like to do is to have a type-level function from the type of a given color to a <code>Symbol</code> representing the color’s name. Let’s call our function <code>ColorName</code>.</p>
<p>But what exactly is a type-level function? A plain haskell function is a function from a value to a value. We can think of a typeclass as a function from a type to a value (generally a function from a type to one or more value-level functions values). We can even think of GADTs as a function from a value (the type constructor) to a type. The last piece of our puzzle then, are <em>Type Families</em>, which we can think of as functions from types to other types.</p>
<p><img src="../images/typefamilies.png" /></p>
<p>Type families are type-level functions from one type to another type. They come in three different varieties:</p>
<ul>
<li><em>Open type families</em> are similar to type classes. You can define an open type family and then add as many <em>instances</em> to it as you want. We won’t use these in this article.</li>
<li><em>Closed type families</em> are fixed mappings from one set of types to another. If you want to add or change a mapping, you need to edit the type family. You’ll use these later on in this section.</li>
<li><em>Associated type families</em> are open type families that are associated with a particular typeclass. You’ll be using these soon.</li>
</ul>
<p>So, <code>ColorName</code> will be a type family that will map some sort of color to a <code>Symbol</code>. We could do this with an open type family, but then we couldn’t guarantee that <code>ColorName</code> always worked with something that is a color. More importantly in the case of <code>RGBTypeLevel</code>, we can’t use constraints when we’re defining type families, so we’d have to do a lot of extra work to prevent us from trying to get the name of an invalid color.</p>
<p>We also don’t want to use a closed type family, because we don’t want to limit ourselves to a predefined set of colors. That means we’ll be using an <em>associated type family</em>.</p>
<p>Associated type families are <em>associated</em> with a type class, so to create one we first need to have a typeclass. One option we have is to add an associated type family into our <code>IsColor</code> class. If we did that, we’d need to implement the type family for every instance of <code>IsColor</code>. In most cases that would be fine, but we’d have trouble handling our original runtime <code>RGB</code> color. <code>RGB</code> doesn’t have enough type-level information for us to construct a unique and meaningful type-level name.</p>
<p>If adding our associated type to <code>IsColor</code> is out of the question, then we can just create a new typeclass. We’ll call it <code>NamedColor</code>, and we’ll add a constraint to ensure that any <code>NamedColor</code> is also an instance of <code>IsColor</code>:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IsColor</span> a <span class="ot">=&gt;</span> <span class="dt">NamedColor</span> a <span class="kw">where</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ColorName</span><span class="ot"> a ::</span> <span class="dt">Symbol</span></span></code></pre></div>
<p>Now let’s write some instances. We’ll start again with some of our X11 colors. These are easy because we just need to hard code a value for them:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NamedColor</span> <span class="dt">AliceBlue</span> <span class="kw">where</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ColorName</span> _ <span class="ot">=</span> <span class="st">&quot;AliceBlue&quot;</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NamedColor</span> <span class="dt">Plum</span> <span class="kw">where</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ColorName</span> <span class="dt">Plum</span> <span class="ot">=</span> <span class="st">&quot;Plum&quot;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NamedColor</span> <span class="dt">RebeccaPurple</span> <span class="kw">where</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ColorName</span> <span class="dt">RebeccaPurple</span> <span class="ot">=</span> <span class="st">&quot;RebeccaPurple&quot;</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- many other colors omitted for brevity</span></span></code></pre></div>
<p>You can see in these examples that the syntax for implementing a type family is similar to using patterns to implement a value level function:</p>
<pre><code>type TypeFamilyName TypeName = TypeResult</code></pre>
<p>What about <code>RGBTypeLevel</code> colors? Let’s look at two different approaches for naming type-level RGB colors. First, let’s consider the common case where a user may want to define some RGB color and give it a human-readable name. In that case, we can create a new type, <code>NamedRGB</code> to handle tracking our color name.</p>
<p><code>NamedRGB</code> will be pretty much exactly like <code>RGBTypeLevel</code>, but we’ll add an extra type parameter, <code>name</code>, to track the name we want to associate with it. You’ll also notice that we’ll also get an opportunity to reuse our <code>ValidRGB</code> constraint from earlier:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NamedRGB</span> (<span class="ot">name ::</span> <span class="dt">Symbol</span>) (<span class="ot">r ::</span> <span class="dt">Nat</span>) (<span class="ot">g ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>) <span class="ot">=</span> <span class="dt">NamedRGB</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ValidRGB</span> r g b <span class="ot">=&gt;</span> <span class="dt">IsColor</span> (<span class="dt">NamedRGB</span> name r g b) <span class="kw">where</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>  toRGB _ <span class="ot">=</span> toRGB (<span class="dt">RGBTypeLevel</span><span class="ot"> ::</span> <span class="dt">RGBTypeLevel</span> r g b)</span></code></pre></div>
<p>Creating a <code>NamedColor</code> instance is even easier than it was for our X11 colors, because we only have a single instance to write. Since we already have a the name of the color carried around as part of it’s type, we only need to return that to satisfy <code>ColorName</code>:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> (<span class="dt">NamedRGB</span> name r g b) <span class="ot">=&gt;</span> <span class="dt">NamedColor</span> (<span class="dt">NamedRGB</span> name r g b) <span class="kw">where</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ColorName</span> _ <span class="ot">=</span> name</span></code></pre></div>
<p>Let’s tackle one more relatively easy <code>NamedRGB</code> instance. Consider the problem that right now we have a lot of colors, for example all of the X11 colors, that are named in ways that don’t cleanly map to the use that they’ll eventually be put to. As it stands, if we wanted to theme our system so that the background was <code>RebeccaPurple</code> we’d need to <code>lookupColor @"RebeccaPurple"</code>. We’re back to our original problem of needing everything that is using our theming system to get updated all at once, or else risk things looking bad.</p>
<p>It would be nice if we could just say <code>lookupColor @"background-text"</code>.</p>
<p>This turns out to be easy if we combine an existential type with a phantom type parameter. We’ll create a new wrapper type, <code>RenameColor</code> that will let us provide a renaming for any other color:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RenameColor</span> (<span class="ot">name ::</span> <span class="dt">Symbol</span>) <span class="ot">=</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> color<span class="op">.</span> <span class="dt">IsColor</span> color <span class="ot">=&gt;</span> <span class="dt">RenameColor</span> color</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> (<span class="dt">RenameColor</span> name) <span class="kw">where</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>  toRGB (<span class="dt">RenameColor</span> c) <span class="ot">=</span> toRGB c</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NamedColor</span> (<span class="dt">RenameColor</span> name) <span class="kw">where</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ColorName</span> _ <span class="ot">=</span> name</span></code></pre></div>
<p>Before we move on, let’s look at a demo. We’ll write a functions to help us get runtime names of <code>NamedColor</code> colors:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="ot">colorNameVal ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">KnownSymbol</span> (<span class="dt">ColorName</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>colorNameVal _ <span class="ot">=</span> symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>(<span class="dt">ColorName</span> a)</span></code></pre></div>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>λ namedRGBRed <span class="ot">=</span> <span class="dt">NamedRGB</span> <span class="op">@</span><span class="st">&quot;red&quot;</span> <span class="op">@</span><span class="dv">255</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">0</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>λ colorNameVal namedRGBRed</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;red&quot;</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>λ rebeccaPurple <span class="ot">=</span> <span class="dt">RebeccaPurple</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>λ colorNameVal rebeccaPurple</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;RebeccaPurple&quot;</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>λ veryRed <span class="ot">=</span> <span class="dt">RenameColor</span> <span class="op">@</span><span class="st">&quot;very red&quot;</span> namedRGBRed</span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>λ colorNameVal veryRed</span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;very red&quot;</span></span></code></pre></div>
<p>Now we can create RGB colors with names at the type level, refer to X11 colors by type, and even rename types however we wish to ensure they fit well with our desired color scheme. This makes our type-level theme implementation <em>nearly</em> complete. We just have one thing left to finish.</p>
<h4 id="naming-rgbtypelevel">Naming <code>RGBTypeLevel</code></h4>
<p>So far we’ve avoided giving a name to plain <code>RGBTypeLevel</code> values. In a way, this makes sense. <code>RGBTypeLevel</code> is the way that we deal with ad-hoc raw color values in our type level theming system. If we wanted to use a color with a specific name we have several ways to do it. That said, there are two compelling reasons why we might want to provide an instance of <code>NamedColor</code> for <code>RGBTypeLevel</code> values:</p>
<p>First, if we can consistently provide a name for all of the different kinds of colors that we’re dealing with in our theming system, we can make use of that information for common code to handle things like naming runtime style elements, or generating nice error messages. For example, it would be nice if we could call <code>colorNameVal</code> on some <code>RGBTypeLevel</code> value to get it’s name at runtime.</p>
<p>Second, by using the same naming system for raw RGB values that we have for other colors, we give users the option to replace colors that are being used directly by theme consumers. Imagine for instance that an external library were using some hard coded low contract text and background colors. If those hard-coded values still appeared to the theming system as regular named colors, the user has the opportunity to replace them with higher-contract alternatives.</p>
<p>Luckily, it’s very achievable to create a <code>NamedColor</code> instance for <code>RGBTypeLevel</code>, but it’ll take a little bit more work that we’ve had to do for our previous instances. Let’s start with a demo of what we’d like to see:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>λ colorNameVal <span class="op">$</span> <span class="dt">RGBTypeLevel</span> <span class="op">@</span><span class="dv">255</span> <span class="op">@</span><span class="dv">100</span> <span class="op">@</span><span class="dv">50</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;#FF6432&quot;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>λ colorNameVal <span class="op">$</span> <span class="dt">RGBTypeLevel</span> <span class="op">@</span><span class="dv">0</span> <span class="op">@</span><span class="dv">16</span> <span class="op">@</span><span class="dv">0</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;#001000&quot;</span></span></code></pre></div>
<p>Essentially, we’d like to convert our RGB colors into a hex string, at the type level. Let’s build this from the top down, staring with our typeclass instance:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">6</span> <span class="op">:++:</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> a <span class="op">:++:</span> b <span class="ot">=</span> <span class="dt">AppendSymbol</span> a b</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> (<span class="dt">RGBTypeLevel</span> r g b) <span class="ot">=&gt;</span> <span class="dt">NamedColor</span> (<span class="dt">RGBTypeLevel</span> r g b) <span class="kw">where</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ColorName</span> _ <span class="ot">=</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;#&quot;</span> <span class="op">:++:</span> <span class="dt">PadNatHex</span> r <span class="op">:++:</span> <span class="dt">PadNatHex</span> g <span class="op">:++:</span> <span class="dt">PadNatHex</span> b</span></code></pre></div>
<p>You can see here that we’ve started by defining a type operator, <code>:++:</code>. This is a convenience function that makes it easier to see the formatting that we’re using as we’re starting to construct our final Symbol. The symbol itself starts with a “#” just like the output string. The rest of the string seems to be constructed from calls to <code>PadNatHex</code> with each of our color channels.</p>
<p>Since we know that <code>r</code>, <code>g</code>, and <code>b</code> must be types, and the result of <code>PadNatHex r</code> must be a Symbol, it stands to reason that <code>PadNatHex</code> must be a type family, and indeed it is, our first <em>closed type family</em>.</p>
<p><code>PadNatHex</code> is a type family that converts a <code>Nat</code> into a <code>Symbol</code> representing it’s hex value, zero-padded out to 2 decimal places. We have to do this to prevent ambiguity, since a string like <code>#ffff</code> could be interpreted as any of:</p>
<ul>
<li><code>ff 0f 0f</code></li>
<li><code>0f ff 0f</code></li>
<li><code>0f 0f ff</code></li>
</ul>
<p>So, we’ll create a type family to map any 1 or 2 digit hex value into a zero-padded 2-digit hex value:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">PadNatHex</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="kw">where</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PadNatHex</span> n <span class="ot">=</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">IfThenElse</span> (n <span class="op">&lt;=?</span> <span class="dv">15</span>) (<span class="st">&quot;0&quot;</span> <span class="op">:++:</span> <span class="dt">NatHex</span> n) (<span class="dt">NatHex</span> n)</span></code></pre></div>
<p>So the implementation here is that if our number is less than or equal to 15 (meaning it would map to a single-digit hex value) we call <code>NatHex</code> and prefix “0” to it. Otherwise, we just return the result of calling <code>NatHex</code>.</p>
<p>At this point you might be a bit surprised to see <code>IfThenElse</code> being used in type-level code. After all, at first glance an <code>if</code> expression hardly seems like something that makes sense at the type level, but it does work and can be extremely convenient. Let’s look at how it’s implemented.</p>
<p>At the value level in haskell, an <code>if</code> expression takes a boolean predicate, and two values of the same type, and returns the first one if the predicate is <code>True</code>, or the second one if the predicate is <code>False</code>. We can fairly easily translate that logic into a closed type family:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">IfThenElse</span> (<span class="ot">p ::</span> <span class="dt">Bool</span>) (<span class="ot">t ::</span> a) (<span class="ot">f ::</span> a)<span class="ot"> ::</span> a <span class="kw">where</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IfThenElse</span> <span class="dt">True</span> t f <span class="ot">=</span> t</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IfThenElse</span> <span class="dt">False</span> t f <span class="ot">=</span> f</span></code></pre></div>
<p>If <code>p</code> is <code>True</code> then we completely ignore the second type and return the first type. Similarly if <code>p</code> is <code>False</code> we ignore the first type and return the second. As long as both types have the same Kind, everyone works as expected.</p>
<p>You’ll notice here that although we’re using a concrete Kind for <code>p</code>, we’re using a kind variable, <code>a</code> for the branches and return kind. To allow this we’ll also need to add another friendly ghc extension: <code>PolyKinds</code></p>
<p>So, in the particular case of our implementation of <code>PadNatHex</code>, <code>IfThenElse</code> takes a <code>Bool</code> and two <code>Symbols</code> and returns the first symbol if <code>n</code> is less than, or equal to, 255, and the second symbol otherwise. Our symbols come from <code>NatHex</code>, another closed type family.</p>
<p>The implementation of <code>NatHex</code> is a bit verbose. It’s also the first example we have of a <em>recursive type family</em>. Like type classes and value level functions, we can recursively call type families when we need to a bit more than we can do with just a straightforward mapping.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">NatHex</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="kw">where</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">0</span> <span class="ot">=</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">1</span> <span class="ot">=</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">2</span> <span class="ot">=</span> <span class="st">&quot;2&quot;</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">3</span> <span class="ot">=</span> <span class="st">&quot;3&quot;</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">4</span> <span class="ot">=</span> <span class="st">&quot;4&quot;</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">5</span> <span class="ot">=</span> <span class="st">&quot;5&quot;</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">6</span> <span class="ot">=</span> <span class="st">&quot;6&quot;</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">7</span> <span class="ot">=</span> <span class="st">&quot;7&quot;</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">8</span> <span class="ot">=</span> <span class="st">&quot;8&quot;</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">9</span> <span class="ot">=</span> <span class="st">&quot;9&quot;</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">10</span> <span class="ot">=</span> <span class="st">&quot;A&quot;</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">11</span> <span class="ot">=</span> <span class="st">&quot;B&quot;</span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">12</span> <span class="ot">=</span> <span class="st">&quot;C&quot;</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">13</span> <span class="ot">=</span> <span class="st">&quot;D&quot;</span></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">14</span> <span class="ot">=</span> <span class="st">&quot;E&quot;</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> <span class="dv">15</span> <span class="ot">=</span> <span class="st">&quot;F&quot;</span></span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NatHex</span> n <span class="ot">=</span> <span class="dt">NatHex</span> (<span class="dt">Div</span> n <span class="dv">16</span>) <span class="op">:++:</span> <span class="dt">NatHex</span> (<span class="dt">Mod</span> n <span class="dv">16</span>)</span></code></pre></div>
<p>Our particular implementation of <code>NatHex</code> is a little bit brute-forced- for every decimal number 0 through 15 we manually match it to one of the 16 hex digits 0 through F. In the recursive case, we split out the lower and upper digits and recursively call <code>NatNex</code> on each half, appending the two resulting symbols.</p>
<p>Now that we’ve walked through all of the things we need to implement to support our <code>NamedColor</code> instance for <code>RGBTypeLevel</code> let’s look at the instance itself one more time to help cement everything:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> (<span class="dt">RGBTypeLevel</span> r g b) <span class="ot">=&gt;</span> <span class="dt">NamedColor</span> (<span class="dt">RGBTypeLevel</span> r g b) <span class="kw">where</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ColorName</span> _ <span class="ot">=</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;#&quot;</span> <span class="op">:++:</span> <span class="dt">PadNatHex</span> r <span class="op">:++:</span> <span class="dt">PadNatHex</span> g <span class="op">:++:</span> <span class="dt">PadNatHex</span> b</span></code></pre></div>
<p>At this point, you’ve now built up an entire type-level theming system that will let you safely build configurable themed components that you can customize at compile time. Before we’re done though, we have one more useful feature to add.</p>
<h2 id="bringing-back-support-for-runtime-configuration">Bringing Back Support For Runtime Configuration</h2>
<p>Having a type-safe theming system that we can customize at compile time is great. It gives us the confidence to know that if our system compiles, it will work. Not only that, we’ve given ourselves the tools to ensure that whatever we build can be flexible, and can offer a great degree of consistency.</p>
<p>That said, having the option to configure things at runtime is often desirable, even if it comes at the cost of some safety. Imagine, for example, that you are customizing your desktop environment. You might find that while you are actively trying to find a setup that looks nice you’ll prefer to give up some of the rigor of a type-level theming system in favor of some runtime configuration. Once you have something that you like, it would be nice to then move that theme into the type level to ensure any changes elsewhere in your configuration don’t cause surprising breakages.</p>
<p>So, in this final section, we’d like to build support for a runtime configurable theming system that is fully compatible with all of the type-level theming code we’ve already built.</p>
<h3 id="creating-a-theme-format">Creating A Theme Format</h3>
<p>The first thing we’d like to do is figure out how we’ll represent our theme at runtime. Ideally it should be a format that is easy to read and write, and doesn’t require a great deal of work on our end to parse. JSON meets these criteria reasonably well, and it’s ubiquitous enough to be easily used by people who might be interested in making use of our code themselves.</p>
<p>The schema we’ll use looks like this:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;red&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;rgb&quot;</span><span class="fu">:</span> <span class="st">&quot;#ff0000&quot;</span><span class="fu">},</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;green&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;rgb&quot;</span><span class="fu">:</span> <span class="st">&quot;#00ff00&quot;</span><span class="fu">},</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;blue&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;x11&quot;</span><span class="fu">:</span> <span class="st">&quot;AliceBlue&quot;</span><span class="fu">},</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;text&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;same-as&quot;</span><span class="fu">:</span> <span class="st">&quot;blue&quot;</span><span class="fu">},</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;border&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;same-as&quot;</span><span class="fu">:</span> <span class="st">&quot;text&quot;</span><span class="fu">},</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;inner-border&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;same-as&quot;</span><span class="fu">:</span> <span class="st">&quot;border&quot;</span><span class="fu">},</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;underline&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;same-as&quot;</span><span class="fu">:</span> <span class="st">&quot;inner-border&quot;</span><span class="fu">}</span></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>For the most part, our schema should look pretty straightforward. We’re storing our theme as a JSON object. The keys in the object are the names of the individual theme elements we want to use. The values are themselves json objects that are storing tagged values representing the actual color value.</p>
<p>The values can be either RGB colors, written as a string of hex digits, an X11 color given by its name, or <em>a reference to some other color in the theme</em>.</p>
<p>The last feature will provide some interesting work for us as we’re building the system to support runtime theming. It’s also an important feature to ensure that we can have a consistent look and feel. If we have to re-enter the same color many times, there’s a risk that we’ll end up introducing typos or forgetting to add some particular value. By allowing us to reference a particular color in the theme, we can help to ensure that we reuse the same colors where appropriate to get a consistent theme.</p>
<h4 id="building-the-theme-configuration">Building The Theme Configuration</h4>
<p>We’ll start building support for our runtime theme configuration in a new module, <code>ThemeLoader</code>. Just like when we built our initial runtime theming system, we’ll start this one with a newtype wrapper around a map.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">RuntimeTheme</span> <span class="ot">=</span> <span class="dt">RuntimeTheme</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> getRuntimeTheme ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">ColorValue</span> }</span></code></pre></div>
<p>We’re using an as-yet-to-be-defined type, <code>ColorValue</code>, to hold the actual color elements. Let’s think for a moment about what that might look like…</p>
<p>For RGB and X11 color values, it’s fairly obvious what we should do, so we can start there:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ColorValue</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">RGBValue</span> <span class="dt">RGB</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">X11Value</span> <span class="dt">SomeColor</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- what about &quot;same-as&quot; values?</span></span></code></pre></div>
<p>But how should we handle the references to another color? One naive way that we could handle it is to store the name that we were referencing:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ColorValue</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">RGBValue</span> <span class="dt">RGB</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">X11Value</span> <span class="dt">SomeColor</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OtherColor</span> <span class="dt">String</span></span></code></pre></div>
<p>We can work with this, but it’s a bit of a pain. Imagine how we’d look up a given color element from our map using this representation:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupColor ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RuntimeTheme</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">ColorValue</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>lookupColor keyName sampleTheme<span class="op">@</span>(<span class="dt">RuntimeTheme</span> themeMap) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> Map.lookup keyName themeMap</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> result <span class="kw">of</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">RGBValue</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> result</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">X11Value</span> _ <span class="ot">-&gt;</span> <span class="dt">Just</span> result</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">OtherColor</span> keyName' <span class="ot">-&gt;</span> lookupSampleColor keyName' sampleTheme</span></code></pre></div>
<p>This approach doesn’t let us know that we’re working with a reference. It will either be handled transparently or else fail. Sometimes that could be nice, but for the sake of error handling and troubleshooting it would be nice to know exactly what we’re getting out of our config.</p>
<p>Alternatively we could simply not traverse the references and return the raw color value, but then we’d be putting the onus on the caller to handle the references every single time they call. That’s an even worse option in most cases.</p>
<p>Let’s re-evaluate how we’re storing <code>ColorValue</code>. What if, instead of storing the string, we store a reference to the color that we were trying to look up? That way we could keep the information that we’re in the <code>OtherColor</code> constructor, but make it a little bit easier to deal with looking up the value for anyone using our theming system.</p>
<p>Let’s handle references by creating a new reference type, <code>ColorReference</code>:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ColorReference</span> r a <span class="ot">=</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ColorReference</span> {<span class="ot">unColorReference ::</span> <span class="dt">ExceptT</span> <span class="dt">String</span> (<span class="dt">Reader</span> r) a}</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> ( <span class="dt">Functor</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>                   , <span class="dt">Applicative</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>                   , <span class="dt">Monad</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>                   , <span class="dt">MonadReader</span> r</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>                   , <span class="dt">MonadError</span> <span class="dt">String</span>)</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a><span class="ot">evalColorReference ::</span> r <span class="ot">-&gt;</span> <span class="dt">ColorReference</span> r a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>evalColorReference env <span class="ot">=</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">flip</span> runReader env <span class="op">.</span> runExceptT <span class="op">.</span> unColorReference</span></code></pre></div>
<p>Now we can track a color reference and handle any errors that might crop up- for example a missing color. Let’s refactor our code to make use of this new color reference:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ColorValue</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">RGBValue</span> <span class="dt">RGB</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">X11Value</span> <span class="dt">SomeColor</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OtherColor</span> (<span class="dt">ColorReference</span> <span class="dt">RuntimeTheme</span> <span class="dt">ColorValue</span>)</span></code></pre></div>
<p>Now we can run the majority of the code that we’d want to work with inside of a <code>ColorReference</code> and evaluate it at the end using the theme that we’ve parsed. It’ll work, but we still have the issue that any failed references won’t be resolved right away. In the worse case scenario we have a bad reference in the runtime config that isn’t used for a long time, and then days, weeks, or months later when the color is finally addressed the system crashes unexpectedly.</p>
<p>It would be nice if we could evaluate all of the references right after we load the file and throw an error if any of them were bad. Otherwise, we could return a safe version of the file without runtime errors. To do that, we’d need to create a safe version of <code>ColorValue</code></p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SafeColorValue</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">SafeRGBValue</span> <span class="dt">RGB</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">SafeX11Value</span> <span class="dt">SomeColor</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">SafeOtherColor</span> <span class="dt">SafeColorValue</span></span></code></pre></div>
<p>This is starting to look like a lot of duplicate code. Wouldn’t it be nice if, instead of having to keep two versions of <code>ColorValue</code> around, we could just keep one version that could represent both the safe and unsafe versions? We can!</p>
<p>Let’s start by factoring <code>ColorReference</code> out of our <code>ColorValue</code> type:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ColorValue</span> (<span class="ot">wrapper ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">RGBValue</span> <span class="dt">RGB</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">X11Value</span> <span class="dt">SomeColor</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OtherColor</span> (wrapper (<span class="dt">ColorValue</span> wrapper))</span></code></pre></div>
<p>Now we could define an unsafe color value as one where <code>wrapper</code> is our unresolved <code>ColorReference</code>:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UnsafeColorValue</span> <span class="ot">=</span> <span class="dt">ColorValue</span> (<span class="dt">ColorReference</span> <span class="dt">RuntimeTheme</span>)</span></code></pre></div>
<p>For our safe reference, ideally we wouldn’t have any sort of wrapper at all. A safe <code>OtherColor</code> would just be <code>OtherColor ColorValue</code>- but <code>wrapper</code> has the Kind <code>Type -&gt; Type</code>, so we have to wrap it in <em>something</em>.</p>
<p>The <code>Identity</code> type from <code>Data.Functor.Identity</code> is useful for exactly this purpose. It provides a simple wrapper around a type. It introduces a layer of indirection, and we have to extract values with <code>runIdentity</code>, but otherwise it doesn’t modify the underlying value that it’s wrapping. That makes it a great candidate for our safe color value:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SafeColorValue</span> <span class="ot">=</span> <span class="dt">ColorValue</span> <span class="dt">Identity</span></span></code></pre></div>
<p>So now we have safe and unsafe color types, we need to update <code>RuntimeTheme</code>. We could create two brand new types:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SafeRuntimeTheme</span> <span class="ot">=</span> <span class="dt">SafeRuntimeTheme</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>  { <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">SafeColorValue</span> }</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">UnsafeRuntimeTheme</span> <span class="ot">=</span> <span class="dt">UnsafeRuntimeTheme</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>  { <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">UnsafeRuntimeTheme</span> }</span></code></pre></div>
<p>But now we’ve moved the duplication problem up one layer in our code without solving it. Let’s go back to the drawing board for a moment.</p>
<p>We created safe and unsafe versions of <code>ColorValue</code> by adding a type parameter. Maybe instead, we can make safe and unsafe versions of <code>RuntimeTheme</code> that take a parameter and pass it along to <code>ColorValue</code>:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">RuntimeTheme'</span> (<span class="ot">wrapper ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">=</span> <span class="dt">RuntimeTheme'</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> getRuntimeTheme ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> (<span class="dt">ColorValue</span> wrapper) }</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RuntimeTheme</span> <span class="ot">=</span> <span class="dt">RuntimeTheme'</span> <span class="dt">Identity</span></span></code></pre></div>
<p>That’ll work for our safe theme. What about our unsafe theme. The problem seems straightforward- let’s just pass in our <code>ColorReference</code>:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UnsafeTheme</span> <span class="ot">=</span> <span class="dt">RuntimeTheme'</span> (<span class="dt">ColorReference</span> (<span class="dt">RuntimeTheme'</span> (<span class="op">Col...</span></span></code></pre></div>
<p>Well then- it looks like we’ve created an infinite loop in the type system. Unlike normal recursive data which still has a finite type, we can’t actually create values with truly infinite types.</p>
<p>Thankfully, this problem can be solved with an extra layer of indirection. We can’t hold a reference to <code>RuntimeTheme'</code> because it’s parameterized by the reference we want to hold, but we can add a new type that doesn’t take any type parameters. This will allow us to break the recursion.</p>
<p>Since this new type that we add will hold our raw unprocessed runtime theme, let’s call it <code>RawRuntimeTheme</code>:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">RawRuntimeTheme</span> <span class="ot">=</span> <span class="dt">RawRuntimeTheme</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot">getRawRuntimeTheme ::</span> <span class="dt">RuntimeTheme'</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>)}</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> (<span class="dt">FromJSON</span>)</span></code></pre></div>
<p>We’re forcing a level of indirection here, by running everything through <code>RawRuntimeTheme</code>, but it nicely solves the problem of infinite types.</p>
<p>Before we move on from the initial configuration, let’s add a couple of things to our runtime config. First, we need to add a <code>FromJSON</code> instance to <code>RawRuntimeTheme</code>. This will make it easy for us to load the configuration file.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> (<span class="dt">ColorValue</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>)) <span class="kw">where</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>  parseJSON <span class="ot">=</span> withObject <span class="st">&quot;color&quot;</span> <span class="op">$</span> \val <span class="ot">-&gt;</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    parseRGBElement val <span class="op">&lt;|&gt;</span> parseX11Element val <span class="op">&lt;|&gt;</span> parseRefElement val</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>      parseRGBElement val <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>        t <span class="ot">&lt;-</span> val <span class="op">.:</span> <span class="st">&quot;rgb&quot;</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">RGBValue</span> <span class="op">&lt;$&gt;</span> parseRGB t</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>      parseX11Element val <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>        t <span class="ot">&lt;-</span> val <span class="op">.:</span> <span class="st">&quot;x11&quot;</span></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">X11Value</span> <span class="op">&lt;$&gt;</span> parseX11Color t</span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>      parseRefElement val <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>        refName <span class="ot">&lt;-</span> val <span class="op">.:</span> <span class="st">&quot;same-as&quot;</span></span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> <span class="op">.</span> <span class="dt">OtherColor</span> <span class="op">$</span> generateRef refName</span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true" tabindex="-1"></a>      generateRef name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb126-18"><a href="#cb126-18" aria-hidden="true" tabindex="-1"></a>        colors <span class="ot">&lt;-</span> asks (getRuntimeTheme <span class="op">.</span> getRawRuntimeTheme)</span>
<span id="cb126-19"><a href="#cb126-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> Map.lookup name colors <span class="kw">of</span></span>
<span id="cb126-20"><a href="#cb126-20" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="st">&quot;Referenced color not found: &quot;</span> <span class="op">&lt;&gt;</span> name</span>
<span id="cb126-21"><a href="#cb126-21" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> color' <span class="ot">-&gt;</span> <span class="fu">pure</span> color'</span></code></pre></div>
<p>As you can see, we only define an instance of <code>FromJSON</code> for the unsafe version of our runtime theme. Each time we see a “same-as” field, we generate a new reader computation that we can resolve later, after we’ve finished processing the entire document. This approach means we can easily handle cases where we reference a color that hasn’t yet been defined.</p>
<p>The second utility function we need is a way to convert a raw runtime theme into a safe one, strictly, so that we can find out if we have any errors early on. We’ll start by writing a function to evaluate a single <code>ColorValue</code>:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dereferenceColorValue ::</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RawRuntimeTheme</span> <span class="ot">-&gt;</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ColorValue</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>) <span class="ot">-&gt;</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">ColorValue</span> <span class="dt">Identity</span>)</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>dereferenceColorValue env colorValue <span class="ot">=</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> colorValue <span class="kw">of</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">RGBValue</span> r <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RGBValue</span> r</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">X11Value</span> c <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">X11Value</span> c</span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">OtherColor</span> r <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>      referencedColor <span class="ot">&lt;-</span> dereferenceColorValue env <span class="op">=&lt;&lt;</span> evalColorReference env r</span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> referencedColor <span class="kw">of</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">OtherColor</span> _ <span class="ot">-&gt;</span> <span class="fu">pure</span> referencedColor</span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">OtherColor</span> referencedColor</span></code></pre></div>
<p>And we can use this function to traverse the entire raw configuration map, giving us a safe map, or an error if we’ve ended up with any missing references:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalConfig ::</span> <span class="dt">RawRuntimeTheme</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">RuntimeTheme</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>evalConfig rawConfig <span class="ot">=</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="dt">RuntimeTheme'</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> <span class="fu">traverse</span> (dereferenceColorValue rawConfig)</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> getRuntimeTheme</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> getRawRuntimeTheme</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> rawConfig</span></code></pre></div>
<p>Third, we should make <code>ColorValue</code> have an instance of <code>IsColor</code> so that we can make sure it works with the rest of our theming system:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsColor</span> (<span class="dt">ColorValue</span> <span class="dt">Identity</span>) <span class="kw">where</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>  toRGB (<span class="dt">RGBValue</span> rgb) <span class="ot">=</span> rgb</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>  toRGB (<span class="dt">X11Value</span> c) <span class="ot">=</span> toRGB c</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>  toRGB (<span class="dt">OtherColor</span> ref) <span class="ot">=</span> toRGB ref</span></code></pre></div>
<p>The last bit of utility code we need to add is to derive a couple of <code>Show</code> instances to make it easier for us to test things in ghci. We can’t derive an instance of <code>Show</code> for the unsafe versions of our types, because they have unevaluated references. We’ll work around that by using the <code>StandaloneDeriving</code> extension to allow us to derive <code>Show</code> just for our safe instances:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">ColorValue</span> <span class="dt">Identity</span>)</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">RuntimeTheme</span></span></code></pre></div>
<p>With our utility functions and <code>Show</code> instances in place, now we can build a small demo to load a theme config from disk and print it out:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="ot">loadRuntimeTheme ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">RuntimeTheme</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>loadRuntimeTheme p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BS.readFile p</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> eitherDecode' contents <span class="op">&gt;&gt;=</span> evalConfig <span class="kw">of</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">ioError</span> <span class="op">$</span> <span class="fu">userError</span> err</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> val <span class="ot">-&gt;</span> <span class="fu">pure</span> val</span></code></pre></div>
<p>If we run this in ghci we’ll see all of the elements of our theme have been resolved just as we’d hoped:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>λ loadRuntimeTheme <span class="st">&quot;../theme.json&quot;</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="dt">RuntimeTheme'</span> {getRuntimeTheme <span class="ot">=</span> fromList [</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Results omitted for brevity</span></span></code></pre></div>
<p>And if we modify our input to contain a dangling reference, we’ll get an error exactly as we’d hoped:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>λ loadRuntimeTheme <span class="st">&quot;../theme.json&quot;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> user <span class="fu">error</span> (<span class="dt">Referenced</span> color <span class="fu">not</span> found<span class="op">:</span> bad<span class="op">-</span>reference)</span></code></pre></div>
<h4 id="stripping-away-the-identity-indirection">Stripping Away The Identity Indirection</h4>
<p>One outstanding downside to our current theme config is the need for too much indirection unwrapping identity values that aren’t buying us any real value. We have to deal with unwrapping our <code>RawThemeConfig</code> true, but that is more of a one-time cost. The <code>Identity</code> wrappers are persistent and a pain when it comes to using the library.</p>
<p>We’ve seen that we have to pass some sort of a type constructor into <code>ColorValue</code>, and that type constructor will be applied to our <code>OtherColor</code>’s value. There’s not much we can do about that without a significant refactor. If only there were a way to erase the <code>Identity</code> at compile time, and eliminate the indirection.</p>
<p>Let’s rephrase that last sentence and see if we can come up with an idea. “If only there were a function from an <code>Identity ColorValue</code> to a <code>ColorValue</code>, we could use it to erase the <code>Identity</code> wrapper at compile time“. A function from a type to another type sounds like the job for… you guessed it, another type family.</p>
<p>The particular pattern that we’re implementing right now is well-known in some haskell circles as the “Higher-Kinded Data” pattern. In homage to it, we’ll name our type family <code>HKD</code>.</p>
<p>Our <code>HKD</code> type family will be one of the most straightforward type families you’ll implement as you work through this article, but it’s also a pattern that will be commonly useful:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">HKD</span> (<span class="ot">wrapper ::</span> a <span class="ot">-&gt;</span> a) (<span class="ot">value ::</span> a)<span class="ot"> ::</span> a <span class="kw">where</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HKD</span> <span class="dt">Identity</span> value <span class="ot">=</span> value</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HKD</span> wrapper value <span class="ot">=</span> wrapper value</span></code></pre></div>
<p>This type family takes a higher-kinded wrapper type, and simply erases it if it happens to be <code>Identity</code>. We can get a feel for this in ghci by working through a few examples:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> (<span class="dt">HKD</span> <span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>(<span class="dt">HKD</span> <span class="dt">Maybe</span> <span class="dt">Int</span>)<span class="ot"> ::</span> <span class="dt">Type</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> (<span class="dt">HKD</span> <span class="dt">Identity</span> <span class="dt">Int</span>)</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>(<span class="dt">HKD</span> <span class="dt">Identity</span> <span class="dt">Int</span>)<span class="ot"> ::</span> <span class="dt">Type</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>We can even look at some more concrete examples of the sort of types that we might have in our theme config:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> (<span class="dt">HKD</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ColorValue</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>)))</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>(<span class="dt">HKD</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>)</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ColorValue</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>)))<span class="ot"> ::</span> <span class="dt">Type</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">ColorReference</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">RawRuntimeTheme</span> (<span class="dt">ColorValue</span> (<span class="dt">ColorReference</span> <span class="dt">RawRuntimeTheme</span>))</span></code></pre></div>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> (<span class="dt">HKD</span> <span class="dt">Identity</span> (<span class="dt">ColorValue</span> (<span class="dt">Identity</span>)))</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>(<span class="dt">HKD</span> <span class="dt">Identity</span> (<span class="dt">ColorValue</span> (<span class="dt">Identity</span>)))<span class="ot"> ::</span> <span class="dt">Type</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">ColorValue</span> <span class="dt">Identity</span></span></code></pre></div>
<p>Using our <code>HKD</code> type family to simplify our safe <code>ColorValue</code> is a small refactor:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ColorValue</span> w</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">RGBValue</span> <span class="dt">RGB</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">X11Value</span> <span class="dt">SomeColor</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">OtherColor</span> (<span class="dt">HKD</span> w (<span class="dt">ColorValue</span> w))</span></code></pre></div>
<p>That’s it! We don’t need to change any of our type aliases that pass around <code>Identity</code>, and we don’t need to change any of the code we’ve written so far in our example. Everything will just transparently work with one less level of indirection.</p>
<h3 id="using-runtimetheme-with-our-typesafe-theming-engine">Using <code>RuntimeTheme</code> With Our Typesafe Theming Engine</h3>
<p>Now we come to the final part of this article. We have created a typesafe theming system that will allow us to create a safe instance of a theme, and we’ve added the ability to define a less safe but more flexible runtime theme using JSON. The last question we have to answer is: “How can we make our runtime theme configuration work with functions that require a typesafe theme instance?”</p>
<p>What we need to do is to have a way to check that a given runtime theme can satisfy the requirements of a <code>Theme</code> that we’ve defined at compile-time. This lets us specify the theme elements that need to be present, and ensure that they all exist in the final version of the theme that we’ve loaded.</p>
<p>Let’s start by writing a new function, <code>validateThemeConfig</code> that will check a runtime theme configuration against a static theme:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="ot">validateThemeConfig ::</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> (<span class="ot">theme ::</span> <span class="dt">Theme</span>)<span class="op">.</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ValidateThemeInstance</span> theme <span class="dt">ThemeInstance</span> <span class="ot">=&gt;</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RuntimeTheme</span> <span class="ot">-&gt;</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">ThemeInstance</span> theme)</span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>validateThemeConfig <span class="ot">=</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>  validateThemeInstance <span class="op">.</span> Map.map <span class="dt">SomeColor</span> <span class="op">.</span> getRuntimeTheme</span></code></pre></div>
<p>Most of the heavy lifting in this function seems to be handled by the <code>validateThemeInstance</code> function that’s part of the <code>ValidateThemeInstance</code> typeclass. As you can guess, we’re using a typeclass here because we’ll need to map the particular type of the target <code>Theme</code> with the elements of our map, color by color:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ValidateThemeInstance</span> (<span class="ot">theme ::</span> <span class="dt">Theme</span>) (<span class="ot">a ::</span> <span class="dt">Theme</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="kw">where</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  validateThemeInstance ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">SomeColor</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> (a theme)</span></code></pre></div>
<p>Our typeclass lets us convert a runtime map to any sort of type-safe theme container, but for our purposes we’re really only interested in converting it to a <code>ThemeInstance</code>. Just like with the other typeclasses we’ve written so far, we’ll start with the base case of an empty theme:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ValidateThemeInstance</span> '[] <span class="dt">ThemeInstance</span> <span class="kw">where</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>  validateThemeInstance theme <span class="ot">=</span> <span class="dt">Right</span> (<span class="dt">ThemeInstance</span> theme)</span></code></pre></div>
<p>This is a pretty easy instance to write. If we have an empty theme then literally any map will satisfy all of the zero required elements, and we can just return a new empty theme.</p>
<p>Our recursive instance will be a little bit more involved. As we’ve done several times now, we’ll start our instance by pattern matching out the head of our current theme from the tail, and adding a recursive constraint on the tail of our theme list.</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">KnownSymbol</span> currentColor</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">ValidateThemeInstance</span> rest <span class="dt">ThemeInstance</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ValidateThemeInstance</span> (currentColor <span class="op">:</span> rest) <span class="dt">ThemeInstance</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span></code></pre></div>
<p>The implementation of <code>validateThemeInstance</code> will follow many of the same beats that we’ve hit throughout this article. We’ll start by getting the name of the current theme element as a runtime string using <code>symbolVal</code>:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>validateThemeInstance theme <span class="ot">=</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> targetColor <span class="ot">=</span> symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>currentColor</span></code></pre></div>
<p>Next, we’ll see if we can find that element as a key in the runtime map. If not, we’ll return an error because a key was missing:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> Map.lookup targetColor theme <span class="kw">of</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> colorName <span class="ot">=</span> symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>currentColor</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> <span class="dt">Left</span> <span class="op">$</span> <span class="st">&quot;missing color: &quot;</span> <span class="op">&lt;&gt;</span> colorName</span></code></pre></div>
<p>If we do find the current color, then we need to make a recursive call to ensure that the rest of the list is valid. If it is, we’ll add the current color to the new theme instance:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ThemeInstance</span> m) <span class="ot">&lt;-</span> validateThemeInstance <span class="op">@</span>rest theme</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">ThemeInstance</span> m</span></code></pre></div>
<p>Our final instance ends up looking like this:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">KnownSymbol</span> currentColor</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">ValidateThemeInstance</span> rest <span class="dt">ThemeInstance</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ValidateThemeInstance</span> (currentColor <span class="op">:</span> rest) <span class="dt">ThemeInstance</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>  validateThemeInstance theme <span class="ot">=</span></span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> targetColor <span class="ot">=</span> symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>currentColor</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="kw">case</span> Map.lookup targetColor theme <span class="kw">of</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span></span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> colorName <span class="ot">=</span> symbolVal <span class="op">$</span> <span class="dt">Proxy</span> <span class="op">@</span>currentColor</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> <span class="dt">Left</span> <span class="op">$</span> <span class="st">&quot;missing color: &quot;</span> <span class="op">&lt;&gt;</span> colorName</span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">ThemeInstance</span> m) <span class="ot">&lt;-</span> validateThemeInstance <span class="op">@</span>rest theme</span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true" tabindex="-1"></a>            <span class="fu">pure</span> <span class="op">$</span> <span class="dt">ThemeInstance</span> m</span></code></pre></div>
<p>As has become our custom, let’s write a small demo function to see this working. We’ll create some sample theme to test with, and then load our json file and try to validate it against the theme. If so we’ll use the validated theme to look up a couple of colors with <code>lookupColor</code> and print them out.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RuntimeTestTheme</span> <span class="ot">=</span> [<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;green&quot;</span>, <span class="st">&quot;red&quot;</span>]</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a><span class="ot">testQuery ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>testQuery p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>  cfg <span class="ot">&lt;-</span> loadRuntimeTheme p</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> testSampleQuery t <span class="ot">=</span> (lookupColor <span class="op">@</span><span class="st">&quot;red&quot;</span> t, lookupColor <span class="op">@</span><span class="st">&quot;blue&quot;</span> t)</span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>      r <span class="ot">=</span> testSampleQuery <span class="op">&lt;$&gt;</span> validateThemeConfig <span class="op">@</span><span class="dt">RuntimeTestTheme</span> cfg</span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> r</span></code></pre></div>
<h2 id="in-conclusion">In Conclusion</h2>
<p>That’s it! You’ve now built a fully type-safe and flexible compile-time theming system with support for optional runtime configuration. You can easily replace colors, add new elements, and make use of type inference to figure out exactly what colors are needed to theme any given part of your program.</p>
<p>More importantly, as you’ve worked through this article you’ve been introduced to a number of important ideas that will come up when you are making use of type-level programming. From Kinds and recursive type classes to GADTs and type families, making the most of haskell’s type system can help you write better code.</p>
<p>Although the theming system is something I use every day as part of my own desktop configuration, the examples here were admittedly somewhat contrived. You might not want to reach for type level programming for every problem like this, but with any luck you’ll now have the tools at hand to use these techniques in cases where they are suitable.</p>
  </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
